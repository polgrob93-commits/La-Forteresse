<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>La Forteresse â€” Prototype (v0.1)</title>
  <style>
    :root{
      --bg:#0e1116;--panel:#151922;--muted:#768199;--text:#e8ecf3;--accent:#6ea8fe;--blue:#2c7be5;--red:#e55353;--green:#35b86b;--orange:#e6a23c;--tile:#1b2230;--tile2:#1f2736;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(120deg,#0e1116 0%,#0c1018 100%);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .app{max-width:1200px;margin:16px auto;padding:0 12px;display:grid;grid-template-columns:300px 1fr 320px;gap:14px}
    .card{background:var(--panel);border:1px solid #222838;border-radius:16px;box-shadow:0 12px 28px rgba(0,0,0,.35);overflow:hidden}
    .card h2{margin:0;font-size:16px;padding:10px 12px;border-bottom:1px solid #1e2533;background:#121722;color:#cfd7ea}
    .pad{padding:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid #2a3246;background:#192031;color:#cfe1ff;padding:8px 12px;border-radius:10px;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,#3563c9,#234db0);border-color:#1e4aa2;color:white;font-weight:600}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .muted{color:var(--muted)}
    .log{height:220px;overflow:auto;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:#111622;border-radius:10px;padding:10px;border:1px solid #222a3a}

    /* Board */
    .board-wrap{display:grid;place-items:center;padding:12px}
    .board{display:grid;grid-template-columns:repeat(9,1fr);grid-template-rows:repeat(9,1fr);gap:4px;background:#0c1018;padding:8px;border-radius:14px;border:1px solid #1d2433}
    .cell{width:56px;height:56px;border-radius:10px;display:grid;place-items:center;position:relative;user-select:none}
    .cell .coord{position:absolute;inset:auto 4px 4px auto;font-size:10px;color:#8892a6;opacity:.6}
    .cell.playable{background:linear-gradient(180deg,var(--tile),var(--tile2));border:1px solid #242c3e}
    .cell.invalid{background:transparent;border:1px dashed #202636;opacity:.25}
    .cell.orange{outline:2px solid var(--orange)}
    .cell.bluezone{box-shadow:inset 0 0 0 2px rgba(44,123,229,.35)}
    .cell.redzone{box-shadow:inset 0 0 0 2px rgba(229,83,83,.35)}
    .cell.blocked::after{content:"";position:absolute;inset:6px;border-radius:8px;background:repeating-linear-gradient(45deg, #364056 0 6px, #141a27 6px 12px);opacity:.75;outline:2px solid #3a445a}
    .piece{width:38px;height:38px;border-radius:50%;display:grid;place-items:center;font-weight:700;color:#0b0f16;box-shadow:0 6px 12px rgba(0,0,0,.35);border:2px solid rgba(0,0,0,.35)}
    .piece.blue{background:linear-gradient(180deg,#3c9cff,#2c7be5)}
    .piece.red{background:linear-gradient(180deg,#ff6767,#e55353)}
    .fort{width:46px;height:46px;border-radius:12px;display:grid;place-items:center;font-weight:800;color:#0b0f16;box-shadow:0 6px 12px rgba(0,0,0,.35);border:2px solid rgba(0,0,0,.35)}
    .fort.blue{background:linear-gradient(180deg,#afd3ff,#7ab6ff)}
    .fort.red{background:linear-gradient(180deg,#ffb1b1,#ff7e7e)}
    .hp{position:absolute;bottom:-10px;left:50%;transform:translateX(-50%);font-size:11px;color:#cfd7ea;background:#121722;border:1px solid #1d2433;border-radius:8px;padding:2px 6px}

    /* Right panel */
    .hand{display:grid;grid-template-columns:1fr;gap:8px}
    .cardui{background:#141a22;border:1px solid #232a3a;border-radius:12px;padding:10px}
    .cardui h4{margin:0 0 4px;font-size:13px}
    .cardui .small{font-size:11px;color:#9aa5bd}
    .cardui .play{margin-top:8px}

    .tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .tag{font-size:10px;border:1px solid #2a3142;border-radius:999px;padding:2px 6px;color:#aab6cf}
    .pill{display:inline-flex;align-items:center;gap:6px;background:#111827;border:1px solid #253045;border-radius:999px;padding:6px 10px}

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
    .sep{height:1px;background:#202638;margin:10px 0}

    .toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#111825;border:1px solid #263046;border-radius:12px;padding:10px 14px;color:#d7e2ff;box-shadow:0 10px 22px rgba(0,0,0,.4);display:none}
    .toast.show{display:block}

    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;background:#0f1420;border:1px solid #253045;border-bottom-width:2px;border-radius:6px;padding:2px 6px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  </style>
</head>
<body>
  <div class="app">
    <aside class="card">
      <h2>Ã‰tat de la partie</h2>
      <div class="pad">
        <div class="row" style="justify-content:space-between">
          <div class="pill"><strong>Tour:</strong> <span id="turnLabel" class="mono">â€”</span></div>
          <button id="btnStart" class="btn primary">DÃ©terminer le 1er joueur</button>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Forteresse ðŸ”µ</h4>
            <div>PV: <span id="blueHP">10</span></div>
            <div class="small">Case A9 (injouable)</div>
          </div>
          <div class="cardui">
            <h4>Forteresse ðŸ”´</h4>
            <div>PV: <span id="redHP">10</span></div>
            <div class="small">Case I1 (injouable)</div>
          </div>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Phase</h4>
            <div id="phase" class="mono">prÃ©paration</div>
          </div>
          <div class="cardui">
            <h4>ImmunitÃ© (tour 1)</h4>
            <div class="small">J1: <span id="im1">âœ”</span> Â· J2: <span id="im2">âœ”</span></div>
          </div>
        </div>
        <div class="sep"></div>
        <div class="cardui">
          <h4>Actions rapides</h4>
          <div class="row">
            <button class="btn" id="btnPlaceTiles">Placer les 47 tuiles</button>
            <button class="btn" id="btnReset">RÃ©initialiser</button>
          </div>
          <div class="small" style="margin-top:8px">Conseil: <span class="kbd">Clic</span> pour sÃ©lectionner un pion, puis suivez les invites pour jouer les cartes.</div>
        </div>
        <div class="sep"></div>
        <div class="cardui">
          <h4>Journal</h4>
          <div id="log" class="log"></div>
        </div>
      </div>
    </aside>

    <main class="card">
      <h2>Plateau 9Ã—9</h2>
      <div class="board-wrap">
        <div id="board" class="board" aria-label="board"></div>
      </div>
    </main>

    <aside class="card">
      <h2>Main & Pioche</h2>
      <div class="pad">
        <div class="row" style="justify-content:space-between">
          <div class="pill">Joueur actif: <strong id="activePlayer">â€”</strong></div>
          <button id="btnEndTurn" class="btn">Fin de tour</button>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Main (ðŸ”µ)</h4>
            <div id="handBlue" class="hand"></div>
          </div>
          <div class="cardui">
            <h4>Main (ðŸ”´)</h4>
            <div id="handRed" class="hand"></div>
          </div>
        </div>
        <div class="sep"></div>
        <div class="grid3">
          <div class="cardui">
            <h4>Pioches</h4>
            <div class="small">ðŸ”µ: <span id="deckB">â€”</span> Â· ðŸ”´: <span id="deckR">â€”</span></div>
            <div class="small">DÃ©fausses â€” ðŸ”µ: <span id="discB">0</span> Â· ðŸ”´: <span id="discR">0</span></div>
          </div>
          <div class="cardui">
            <h4>Tuiles</h4>
            <div class="small">PlacÃ©es: <span id="tilesCount">0</span> / 47</div>
          </div>
          <div class="cardui">
            <h4>Blocs actifs</h4>
            <div class="small"><span id="blocksActive">0</span> / 6</div>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <div id="toast" class="toast"></div>

  <script>
  /* =====================================================
     LA FORTERESSE â€” Prototype jouable v0.1 (client-side)
     - Plateau 9x9 avec cases jouables/inexistantes
     - Forteresses A9 (bleu) et I1 (rouge)
     - Zones de dÃ©part et zone orange
     - Pions: 7 par joueur (2 PV), forteresse 10 PV
     - Pioches personnelles et mains (5 cartes)
     - Tour 1 avec immunitÃ© et rÃ¨gles spÃ©ciales
     - SystÃ¨me de tuiles (47 alÃ©atoires)
     - Cartes de base implÃ©mentÃ©es (mouvement, attaque CAC/DIST, Ã©change, TP, soin, renfort, bloc/dÃ©bloc)
     NOTE: C'est un prototype jouable. Certaines validations complexes sont simplifiÃ©es.
  ====================================================== */

  const LETTERS = ['A','B','C','D','E','F','G','H','I'];
  const NUMS = [1,2,3,4,5,6,7,8,9];

  // ---- Sets de rÃ¨gles ------------------------------------------------------
  const INVALID = new Set([
    'A1','B1','C1','A2','B2','C2','A3','B3','G9','H9','I9','G8','H8','I8','H7','I7'
  ]);

  const ORANGE = new Set(['D5','E4','E5','E6','F5']);

  const RED_SPAWN = new Set(['G1','G2','G3','H1','H2','H3','I2','I3']);
  const BLUE_SPAWN = new Set(['A8','A7','B9','B8','B7','C9','C8','C7']);

  const FORT_BLUE = 'A9';
  const FORT_RED  = 'I1';

  // All playable cells = grid minus INVALID
  const ALL_CELLS = [];
  for (const L of LETTERS){ for (const n of NUMS){ ALL_CELLS.push(`${L}${n}`); } }
  const PLAYABLE = ALL_CELLS.filter(c=>!INVALID.has(c));

  // Cases oÃ¹ tuiles peuvent apparaÃ®tre (47 au total, pas sur zones de dÃ©part Rouge/Bleue)
  function tileEligibleCells(){
    return PLAYABLE.filter(c=>!RED_SPAWN.has(c) && !BLUE_SPAWN.has(c) && c!==FORT_BLUE && c!==FORT_RED);
  }

  // ---- Etat de la partie ---------------------------------------------------
  const state = {
    turn: 0, // incrÃ©mente Ã  chaque tour complet
    active: 'blue', // 'blue' ou 'red'
    phase: 'prÃ©paration',
    immunity: { p1: true, p2: true }, // tour 1
    firstTurnMode: true, // rÃ¨gles spÃ©ciales
    firstOrder: null, // 'blue' ou 'red' choisi par jet de dÃ©
    blocks: new Set(), // cells bloquÃ©es
    tiles: {}, // cell -> {type:'positive'|'negative'|'blank', key, revealed:false}
    pieces: {
      blue: { fortHP:10, pieces:[], hand:[], deck:[], discard:[] },
      red:  { fortHP:10, pieces:[], hand:[], deck:[], discard:[] }
    },
    selected: null, // {color, id} d'un pion sÃ©lectionnÃ©
    playedThisTurn: 0, // nb de cartes jouÃ©es ce tour
  };

  // ---- Utilitaires ---------------------------------------------------------
  const $ = sel => document.querySelector(sel);
  const el = (tag, props={}) => Object.assign(document.createElement(tag), props);
  const log = (msg) => { const d=$('#log'); const p=el('div'); p.textContent=msg; d.appendChild(p); d.scrollTop=d.scrollHeight; };
  const toast = (msg, ms=1600)=>{ const t=$('#toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),ms); };

  function coordToXY(c){ const L=c[0]; const n=+c.slice(1); return {x:LETTERS.indexOf(L), y:n-1}; }
  function xyToCoord(x,y){ return LETTERS[x]+(y+1); }
  function neighbors4(c){ const {x,y}=coordToXY(c); const out=[]; [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{const nx=x+dx, ny=y+dy; if(nx>=0&&nx<9&&ny>=0&&ny<9){ const nc=xyToCoord(nx,ny); if(!INVALID.has(nc)) out.push(nc); }}); return out; }
  function isLineOfSight(a,b){ // dÃ©gagÃ©e si aucune piÃ¨ce/bloc entre a et b en ligne OU diagonale pure
    const {x:ax,y:ay}=coordToXY(a), {x:bx,y:by}=coordToXY(b);
    const dx = Math.sign(bx-ax), dy=Math.sign(by-ay);
    if(!(ax===bx || ay===by || Math.abs(bx-ax)===Math.abs(by-ay))) return false; // ni ligne ni diag
    let x=ax+dx, y=ay+dy; while(!(x===bx && y===by)){
      const c=xyToCoord(x,y);
      if(state.blocks.has(c)) return false;
      if(getPieceAt(c)) return false;
      x+=dx; y+=dy;
    }
    return true;
  }
  function distManhattan(a,b){ const A=coordToXY(a), B=coordToXY(b); return Math.abs(A.x-B.x)+Math.abs(A.y-B.y); }
  function isAdjacent4(a,b){ return neighbors4(a).includes(b); }

  function getPieceAt(c){
    for(const color of ['blue','red']){
      const p = state.pieces[color].pieces.find(u=>u.cell===c);
      if(p) return {color, unit:p};
    }
    return null;
  }

  // ---- Construction des pioches -------------------------------------------
  // Deck perso: 26 cartes
  // 10 DÃ©placement (rÃ©partition simple 3x2,3x3,2x4,2x5 = 10)
  // 6 CAC/ECH
  // 4 DIST/TP
  // 3 SOIN/RENF
  // 3 BLOC/DEBLOC
  function buildDeck26(){
    const deck=[];
    deck.push(...Array(3).fill({type:'MOVE', steps:2}));
    deck.push(...Array(3).fill({type:'MOVE', steps:3}));
    deck.push(...Array(2).fill({type:'MOVE', steps:4}));
    deck.push(...Array(2).fill({type:'MOVE', steps:5}));
    deck.push(...Array(6).fill({type:'MELEE_SWAP'}));
    deck.push(...Array(4).fill({type:'RANGE_TP'}));
    deck.push(...Array(3).fill({type:'HEAL_REINFORCE'}));
    deck.push(...Array(3).fill({type:'BLOCK_UNBLOCK'}));
    return deck.map((c,i)=>({...c,id:`C${Math.random().toString(36).slice(2,8)}${i}`}));
  }

  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [a[i],a[j]]=[a[j],a[i]];} return a; }

  // ---- Initialisation ------------------------------------------------------
  function initGame(){
    state.pieces.blue = { fortHP:10, pieces:[], hand:[], deck:shuffle(buildDeck26()), discard:[] };
    state.pieces.red  = { fortHP:10, pieces:[], hand:[], deck:shuffle(buildDeck26()), discard:[] };
    state.blocks = new Set();
    state.tiles = {};
    state.turn=0; state.active='blue'; state.phase='prÃ©paration';
    state.immunity={p1:true,p2:true}; state.firstTurnMode=true; state.firstOrder=null;
    state.playedThisTurn=0; state.selected=null;

    const bCells = shuffle([...BLUE_SPAWN]).slice(0,5);
    for(let i=0;i<5;i++){ state.pieces.blue.pieces.push({id:`B${i+1}`, cell:bCells[i], hp:2}); }
    state.pieces.blue.pieces.push({id:`B6`, cell:null, hp:2});
    state.pieces.blue.pieces.push({id:`B7`, cell:null, hp:2});

    const rCells = shuffle([...RED_SPAWN]).slice(0,5);
    for(let i=0;i<5;i++){ state.pieces.red.pieces.push({id:`R${i+1}`, cell:rCells[i], hp:2}); }
    state.pieces.red.pieces.push({id:`R6`, cell:null, hp:2});
    state.pieces.red.pieces.push({id:`R7`, cell:null, hp:2});

    drawUpTo5('blue');
    drawUpTo5('red');

    renderAll();
    log('Nouvelle partie initialisÃ©e. Placez les tuiles (47) puis tirez au sort le premier joueur.');
  }

  // ---- Tuiles --------------------------------------------------------------
  const TILE_POSITIVE = [
    ...Array(5).fill({key:'TIR_ANCRE', kind:'positive'}),
    ...Array(4).fill({key:'REFLEXE', kind:'positive'}),
    ...Array(6).fill({key:'SPRINT', kind:'positive'}),
    ...Array(4).fill({key:'PRESSION', kind:'positive'}),
    ...Array(4).fill({key:'PANSEMENT', kind:'positive'}),
    ...Array(2).fill({key:'MOLETTE', kind:'positive'})
  ];
  const TILE_NEGATIVE = [
    ...Array(3).fill({key:'ACCROC', kind:'negative'}),
    ...Array(2).fill({key:'ANTI_MAGIE', kind:'negative'}),
    ...Array(4).fill({key:'MAIN_LOURDE', kind:'negative'}),
    ...Array(3).fill({key:'DESARME', kind:'negative'}),
    ...Array(2).fill({key:'FAIBLESSE', kind:'negative'}),
    ...Array(2).fill({key:'REVERSE', kind:'negative'})
  ];
  function place47Tiles(){
    state.tiles = {};
    const elig = tileEligibleCells();
    const spots = shuffle([...elig]).slice(0,47);
    const positives = shuffle([...TILE_POSITIVE]);
    const negatives = shuffle([...TILE_NEGATIVE]);
    const blanks = Array(6).fill({key:'BLANK', kind:'blank'});
    const pool = shuffle([...positives, ...negatives, ...blanks]);
    spots.forEach((cell,i)=>{ state.tiles[cell] = {...pool[i], revealed:false}; });
    renderAll();
    log('47 tuiles placÃ©es alÃ©atoirement (non visibles).');
  }

  function revealTileIfAny(cell, actorColor){
    const t = state.tiles[cell];
    if(!t || t.revealed) return;
    t.revealed = true;
    applyTileEffect(cell, t, actorColor);
  }

  function applyTileEffect(cell, tile, color){
    const P = state.pieces[color];
    switch(tile.key){
      case 'TIR_ANCRE':
        log(`[Tuile +] Tir ancrÃ© sur ${cell}: Attaque DIST gratuite immÃ©diate si possible.`);
        const shooter = getPieceAt(cell);
        if(!shooter) break;
        const targets = piecesOf(color==='blue'?'red':'blue').filter(u=>isRangedValid(cell,u.cell));
        if(targets.length){ doRangedAttack(cell, targets[0].cell, color, true); }
        else { draw(color,1); promptDiscard(color,1); }
        break;
      case 'REFLEXE':
        log(`[Tuile +] RÃ©flexe: pioche 1; +1 carte jouable ce tour (plafond +1 via tuile).`);
        draw(color,1);
        state.extraCardThisTurn = (state.extraCardThisTurn||0)+1;
        break;
      case 'SPRINT':
        log(`[Tuile +] Sprint: +2 cases au dÃ©placement gratuit ce tour.`);
        state.extraFreeMove = (state.extraFreeMove||0)+2;
        break;
      case 'PRESSION':
        log(`[Tuile +] Pression: la prochaine Attaque ce tour force l'adversaire Ã  dÃ©fausser 1 carte avant rÃ©solution.`);
        state.pressureThisTurn = true;
        break;
      case 'PANSEMENT':
        log(`[Tuile +] Pansement: +1 PV pion ou forteresse.`);
        const ownUnits = piecesOf(color);
        const hurt = ownUnits.find(u=>u.hp<2);
        if(hurt){ hurt.hp = Math.min(2, hurt.hp+1); }
        else { P.fortHP = Math.max(0, Math.min(10, P.fortHP+1)); }
        break;
      case 'MOLETTE':
        log(`[Tuile +] Molette: placer ou retirer 1 bloc (hors zones Rouge/Bleue/Orange), max 6.`);
        if(state.blocks.size<6){
          const near = neighbors4(cell).find(c=>!state.blocks.has(c) && !RED_SPAWN.has(c) && !BLUE_SPAWN.has(c) && !ORANGE.has(c));
          if(near) state.blocks.add(near);
        } else {
          const any=[...state.blocks][0]; if(any) state.blocks.delete(any);
        }
        break;
      case 'ACCROC':
        log(`[Tuile -] Accroc: fin de tour = piocher jusqu'Ã  4 au lieu de 5.`);
        state.drawTo4 = true;
        break;
      case 'ANTI_MAGIE':
        log(`[Tuile -] Anti-magie: ce pion ne peut pas TÃ©lÃ©porter / Ã‰changer jusquâ€™Ã  la fin de votre tour.`);
        state.noMagicThisTurn = true;
        break;
      case 'MAIN_LOURDE':
        log(`[Tuile -] Main lourde: sur la prochaine attaque, 1/6 ne font que 1 dÃ©gÃ¢t.`);
        state.weakenCritThisTurn = true;
        break;
      case 'DESARME':
        log(`[Tuile -] DÃ©sarmÃ©: aucune Attaque (CAC ou DIST) ce tour. Autres effets autorisÃ©s.`);
        state.disarmedThisTurn = true;
        break;
      case 'FAIBLESSE':
        log(`[Tuile -] Faiblesse: ce pion perd 1 PV.`);
        const u = getPieceAt(cell); if(u) { u.unit.hp -= 1; if(u.unit.hp<=0){ removeUnit(u.color,u.unit.id); }}
        break;
      case 'REVERSE':
        log(`[Tuile -] Reverse: revenir case prÃ©cÃ©dente (ou annulez lâ€™Ã‰change/TP en rÃ©-inversant).`);
        const R = getPieceAt(cell); if(R){ R.unit.hp -=1; if(R.unit.hp<=0){ removeUnit(R.color,R.unit.id); }}
        break;
      case 'BLANK':
      default:
        log(`[Tuile â—‹] Sans effet.`);
    }
    renderAll();
  }

  // ---- Pioche & main -------------------------------------------------------
  function draw(color, n){ const P=state.pieces[color]; while(n-->0 && P.deck.length){ P.hand.push(P.deck.pop()); } updateDeckUI(); }
  function drawUpTo5(color){ const P=state.pieces[color]; while(P.hand.length<5 && P.deck.length){ P.hand.push(P.deck.pop()); } updateDeckUI(); }
  function discard(color, idx){ const P=state.pieces[color]; const [c]=P.hand.splice(idx,1); if(c) P.discard.push(c); updateDeckUI(); renderHands(); }
  function promptDiscard(color, n){ const P=state.pieces[color]; while(n-->0 && P.hand.length){ P.discard.push(P.hand.pop()); }
    updateDeckUI(); renderHands(); }

  // ---- Rendu plateau -------------------------------------------------------
  function renderBoard(){
    const b = $('#board');
    b.innerHTML='';
    for(let y=8;y>=0;y--){
      for(let x=0;x<9;x++){
        const c = xyToCoord(x,y);
        const playable = !INVALID.has(c);
        const cell = el('div',{className:'cell '+(playable?'playable':'invalid')});
        if(ORANGE.has(c)) cell.classList.add('orange');
        if(BLUE_SPAWN.has(c)) cell.classList.add('bluezone');
        if(RED_SPAWN.has(c)) cell.classList.add('redzone');
        if(state.blocks.has(c)) cell.classList.add('blocked');
        cell.dataset.coord=c;
        const q = el('div',{className:'coord',textContent:c}); cell.appendChild(q);

        if(c===FORT_BLUE){ const F = el('div',{className:'fort blue',textContent:'F'}); const hp=el('div',{className:'hp',textContent:state.pieces.blue.fortHP+" PV"}); cell.appendChild(F); cell.appendChild(hp); }
        if(c===FORT_RED){ const F = el('div',{className:'fort red',textContent:'F'});  const hp=el('div',{className:'hp',textContent:state.pieces.red.fortHP+" PV"});  cell.appendChild(F); cell.appendChild(hp); }

        const occ = getPieceAt(c);
        if(occ){ const piece = el('div',{className:'piece '+(occ.color==='blue'?'blue':'red'),textContent:occ.unit.hp}); cell.appendChild(piece); }

        if(playable){
          cell.addEventListener('click', ()=> onCellClick(c));
        }

        b.appendChild(cell);
      }
    }
  }

  function renderHands(){
    function renderSide(color, target){
      const P=state.pieces[color];
      target.innerHTML='';
      P.hand.forEach((card, idx)=>{
        const box = el('div',{className:'cardui'});
        const title = prettyCardName(card);
        box.innerHTML = `<h4>${title}</h4><div class="small">#${card.id}</div>`;
        const playBtn = el('button',{className:'btn play',textContent:'Jouer',onclick:()=>playCard(color, idx)});
        if(state.active!==color) playBtn.disabled=true;
        box.appendChild(playBtn);
        target.appendChild(box);
      });
    }
    renderSide('blue', $('#handBlue'));
    renderSide('red', $('#handRed'));
  }

  function prettyCardName(c){
    switch(c.type){
      case 'MOVE': return `DÃ©placement ${c.steps}`;
      case 'MELEE_SWAP': return 'CAC / Ã‰change';
      case 'RANGE_TP': return 'Attaque Ã  distance / TÃ©lÃ©portation';
      case 'HEAL_REINFORCE': return 'Soin / Renfort';
      case 'BLOCK_UNBLOCK': return 'Blocage / DÃ©blocage';
    }
    return 'Carte';
  }

  function renderTop(){
    $('#turnLabel').textContent = state.turn;
    $('#activePlayer').textContent = state.active==='blue'?'ðŸ”µ Bleu':'ðŸ”´ Rouge';
    $('#phase').textContent = state.phase;
    $('#blueHP').textContent = state.pieces.blue.fortHP;
    $('#redHP').textContent = state.pieces.red.fortHP;
    $('#im1').textContent = state.immunity.p1?'âœ”':'â€”';
    $('#im2').textContent = state.immunity.p2?'âœ”':'â€”';
    $('#tilesCount').textContent = Object.keys(state.tiles).length;
    $('#blocksActive').textContent = state.blocks.size;
    $('#btnEndTurn').disabled = !(state.phase==='actions' || state.phase==='prÃ©paration');
  }

  function updateDeckUI(){
    $('#deckB').textContent = state.pieces.blue.deck.length;
    $('#deckR').textContent = state.pieces.red.deck.length;
    $('#discB').textContent = state.pieces.blue.discard.length;
    $('#discR').textContent = state.pieces.red.discard.length;
  }

  function renderAll(){ renderBoard(); renderHands(); renderTop(); }

  // ---- SÃ©lection & interactions plateau -----------------------------------
  function onCellClick(c){
    const occ = getPieceAt(c);
    if(occ && occ.color===state.active){
      state.selected = { color:occ.color, id:occ.unit.id };
      toast(`SÃ©lection: ${occ.color==='blue'?'ðŸ”µ':'ðŸ”´'} ${occ.unit.id} @ ${c}`);
    } else if(state.selected){
      const sel = findUnit(state.selected.color, state.selected.id);
      if(sel && canFreeStep(sel.cell, c)){
        sel.cell = c; revealTileIfAny(c, state.active); renderAll();
      }
    }
  }

  function findUnit(color, id){ return state.pieces[color].pieces.find(u=>u.id===id); }

  function canFreeStep(from, to){
    if(!from) return false; if(from===to) return false;
    if(!PLAYABLE.includes(to) || state.blocks.has(to)) return false;
    if(getPieceAt(to)) return false;
    return isAdjacent4(from,to);
  }

  // ---- Cartes: exÃ©cution ---------------------------------------------------
  function playCard(color, idx){
    if(state.active!==color){ toast('Pas votre tour.'); return; }
    const maxCards = 3 + (state.extraCardThisTurn?1:0);
    if(state.playedThisTurn>=maxCards){ toast('Limite de cartes jouÃ©es atteinte.'); return; }

    const P = state.pieces[color]; const card = P.hand[idx];

    if(state.firstTurnMode){
      const allowance = (state.active===state.firstOrder?1:2);
      if(state.playedThisTurn>=allowance){ toast(`Tour 1: vous avez dÃ©jÃ  jouÃ© ${allowance} carte(s).`); return; }
    }

    switch(card.type){
      case 'MOVE':
        promptMove(color, card.steps); break;
      case 'MELEE_SWAP':
        promptMeleeOrSwap(color); break;
      case 'RANGE_TP':
        promptRangeOrTP(color); break;
      case 'HEAL_REINFORCE':
        promptHealOrReinforce(color); break;
      case 'BLOCK_UNBLOCK':
        promptBlockOrUnblock(color); break;
    }
  }

  function commitCard(color, idx){ const P=state.pieces[color]; const [c]=P.hand.splice(idx,1); P.discard.push(c); state.playedThisTurn++; renderHands(); updateDeckUI(); }

  // -- MOVE ------------------------------------------------------------------
  function promptMove(color, steps){
    if(!state.selected){ toast('SÃ©lectionnez un de vos pions Ã  dÃ©placer.'); return; }
    const unit = findUnit(state.selected.color, state.selected.id);
    if(!unit || unit.cell===null){ toast('Pion non prÃ©sent sur le plateau.'); return; }
    let remaining = steps;
    function once(){
      toast(`DÃ©placement: ${remaining} case(s) restantes. Cliquez une case adjacente.`);
      const handler = (e)=>{
        const cell = e.target.closest('.cell'); if(!cell) return;
        const to = cell?.dataset?.coord; if(!to) return;
        if(canStep(unit.cell,to)){
          unit.cell = to; revealTileIfAny(to, color); renderAll();
          remaining--; if(remaining===0){
            document.removeEventListener('click', handler, true);
            const idx = state.pieces[color].hand.findIndex(c=>c.type==='MOVE' && c.steps===steps);
            if(idx>-1) commitCard(color, idx);
          }
        }
      };
      document.addEventListener('click', handler, true);
    }
    once();
  }
  function canStep(from,to){
    if(!PLAYABLE.includes(to) || state.blocks.has(to)) return false;
    if(getPieceAt(to)) return false;
    return isAdjacent4(from,to);
  }

  // -- MELEE / SWAP ----------------------------------------------------------
  function promptMeleeOrSwap(color){
    const choice = window.prompt('Entrez "CAC" pour attaquer au corps Ã  corps, ou "ECH" pour Ã©changer :','CAC');
    if(!choice) return;
    if(choice.toUpperCase()==='CAC') promptMelee(color);
    else promptSwap(color);
  }

  function promptMelee(color){
    if(!state.selected){ toast('SÃ©lectionnez un pion attaquant.'); return; }
    const u = findUnit(state.selected.color, state.selected.id);
    if(!u||!u.cell){ toast('Pion non prÃ©sent.'); return; }
    const neigh = neighbors4(u.cell).map(c=>getPieceAt(c)).filter(x=>x&&x.color!==color);
    if(!neigh.length){ toast('Aucun ennemi adjacent.'); return; }
    const target = neigh[0];
    if(isAttackBlockedByImmunity()) { toast('ImmunitÃ© tour 1: attaque annulÃ©e.'); return; }
    if(state.disarmedThisTurn){ toast('DÃ©sarmÃ©: pas d\'attaque ce tour.'); return; }
    if(state.pressureThisTurn){ promptDiscard(color==='blue'?'red':'blue',1); state.pressureThisTurn=false; }
    rollAndApplyDamage(u.cell, target.unit, target.color);
    const idx = state.pieces[color].hand.findIndex(c=>c.type==='MELEE_SWAP');
    if(idx>-1) commitCard(color, idx);
    renderAll();
  }

  function promptSwap(color){
    if(state.noMagicThisTurn){ toast('Anti-magie: pas d\'Ã‰change.'); return; }
    const a = window.prompt('Entrez la coordonnÃ©e de la cible pour Ã‰change (ex: E5) :','');
    if(!a || !PLAYABLE.includes(a)) return;
    const sel = state.selected && findUnit(state.selected.color, state.selected.id);
    if(!sel||!sel.cell){ toast('SÃ©lectionnez d\'abord votre pion.'); return; }
    const occ = getPieceAt(a);
    if(!occ){ toast('Aucun pion sur cette case.'); return; }
    if(occ.color!==color && ((occ.color==='red' && RED_SPAWN.has(occ.unit.cell)) || (occ.color==='blue' && BLUE_SPAWN.has(occ.unit.cell)))){
      toast('Interdit: pion ennemi dans sa zone de dÃ©part.'); return;
    }
    if(!isLineOfSight(sel.cell, occ.unit.cell)){ toast('Pas de ligne de vue.'); return; }
    const tmp = sel.cell; sel.cell = occ.unit.cell; occ.unit.cell = tmp;
    const idx = state.pieces[color].hand.findIndex(c=>c.type==='MELEE_SWAP');
    if(idx>-1) commitCard(color, idx);
    revealTileIfAny(sel.cell, color); revealTileIfAny(occ.unit.cell, occ.color); renderAll();
  }

  // -- RANGE / TP ------------------------------------------------------------
  function promptRangeOrTP(color){
    const choice = window.prompt('Entrez "DIST" pour Attaque Ã  distance ou "TP" pour TÃ©lÃ©portation :','DIST');
    if(!choice) return;
    if(choice.toUpperCase()==='DIST') promptRanged(color);
    else promptTP(color);
  }

  function isRangedValid(from, to){
    const A=coordToXY(from), B=coordToXY(to);
    const dx=Math.abs(A.x-B.x), dy=Math.abs(A.y-B.y);
    const ortho = (dx===0 || dy===0) && (dx+dy>=2 && dx+dy<=4);
    const diag  = (dx===dy) && (dx>=1 && dx<=2);
    if(!(ortho||diag)) return false;
    if(isAdjacent4(from,to)) return false;
    if(!isLineOfSight(from,to)) return false;
    return true;
  }

  function promptRanged(color){
    if(state.disarmedThisTurn){ toast('DÃ©sarmÃ©: pas d\'attaque.'); return; }
    if(!state.selected){ toast('SÃ©lectionnez l\'attaquant.'); return; }
    const u = findUnit(state.selected.color, state.selected.id);
    if(!u||!u.cell){ toast('Pion non prÃ©sent.'); return; }
    const a = window.prompt('Cible (coord) pour Attaque Ã  distance :','');
    if(!a || !PLAYABLE.includes(a)) return; const occ = getPieceAt(a);
    if(!occ || occ.color===color){ toast('Cible invalide.'); return; }
    if(!isRangedValid(u.cell, a)){ toast('PortÃ©e/ligne de vue invalide.'); return; }
    if(isAttackBlockedByImmunity()) { toast('ImmunitÃ© tour 1: attaque annulÃ©e.'); return; }
    if(state.pressureThisTurn){ promptDiscard(color==='blue'?'red':'blue',1); state.pressureThisTurn=false; }
    doRangedAttack(u.cell, a, color, false);
    const idx = state.pieces[color].hand.findIndex(c=>c.type==='RANGE_TP');
    if(idx>-1) commitCard(color, idx);
    renderAll();
  }

  function doRangedAttack(from, to, color, free){
    const target = getPieceAt(to);
    if(!target) { log('Tir: aucune cible.'); return; }
    rollAndApplyDamage(from, target.unit, target.color);
  }

  function promptTP(color){
    if(state.noMagicThisTurn){ toast('Anti-magie: pas de TP.'); return; }
    if(!state.selected){ toast('SÃ©lectionnez le pion Ã  tÃ©lÃ©porter.'); return; }
    const sel = findUnit(state.selected.color, state.selected.id);
    if(!sel||!sel.cell){ toast('Pion non prÃ©sent.'); return; }
    const a = window.prompt('Destination (coord) libre avec LDV (illimitÃ©e). Interdit: zone ennemie.','');
    if(!a || !PLAYABLE.includes(a)) return;
    if(getPieceAt(a) || state.blocks.has(a)) { toast('Case occupÃ©e ou bloquÃ©e.'); return; }
    if(!isLineOfSight(sel.cell, a)) { toast('Pas de ligne de vue.'); return; }
    if(color==='blue' && RED_SPAWN.has(a)) { toast('Interdit: zone rouge.'); return; }
    if(color==='red' && BLUE_SPAWN.has(a)) { toast('Interdit: zone bleue.'); return; }
    sel.cell = a; revealTileIfAny(a,color); const idx=state.pieces[color].hand.findIndex(c=>c.type==='RANGE_TP'); if(idx>-1) commitCard(color, idx); renderAll();
  }

  // -- HEAL / REINFORCE ------------------------------------------------------
  function promptHealOrReinforce(color){
    const choice = window.prompt('"SOIN" pour +2 PV forteresse (max 10) ou "RENF" pour poser un pion en zone de dÃ©part :','SOIN');
    if(!choice) return;
    if(choice.toUpperCase()==='SOIN'){
      const P=state.pieces[color]; P.fortHP = Math.min(10, P.fortHP+2); log(`${color} soigne sa forteresse (+2 PV).`);
    } else {
      const P=state.pieces[color];
      const reserve = P.pieces.find(u=>u.cell===null);
      if(!reserve){ toast('Aucun pion en rÃ©serve.'); return; }
      const zone = color==='blue'? [...BLUE_SPAWN]:[...RED_SPAWN];
      const spot = zone.find(c=>!getPieceAt(c));
      if(!spot){ toast('Zone de dÃ©part pleine.'); return; }
      const onBoard = P.pieces.filter(u=>u.cell).length;
      if(onBoard>=7){ toast('Max 7 pions sur le plateau.'); return; }
      reserve.cell = spot; log(`${color} pose ${reserve.id} en ${spot}.`);
    }
    const idx = state.pieces[color].hand.findIndex(c=>c.type==='HEAL_REINFORCE'); if(idx>-1) commitCard(color, idx);
    renderAll();
  }

  // -- BLOCK / UNBLOCK -------------------------------------------------------
  function promptBlockOrUnblock(color){
    const choice = window.prompt('"BLOC" pour placer un bloc adjacent ortho, "DEBLOC" pour retirer un bloc adjacent :','BLOC');
    if(!choice) return;
    if(choice.toUpperCase()==='BLOC'){
      if(state.blocks.size>=6){ toast('Maximum de blocs actifs atteint (6).'); return; }
      if(!state.selected){ toast('SÃ©lectionnez un pion.'); return; }
      const u=findUnit(state.selected.color,state.selected.id); if(!u||!u.cell){ toast('Pion non prÃ©sent.'); return; }
      const cand = neighbors4(u.cell).find(c=>!state.blocks.has(c) && !getPieceAt(c) && !RED_SPAWN.has(c) && !BLUE_SPAWN.has(c) && !ORANGE.has(c));
      if(!cand){ toast('Aucune case valide autour.'); return; }
      state.blocks.add(cand); log(`Bloc placÃ© en ${cand}.`);
    } else {
      if(!state.selected){ toast('SÃ©lectionnez un pion.'); return; }
      const u=findUnit(state.selected.color,state.selected.id); if(!u||!u.cell){ toast('Pion non prÃ©sent.'); return; }
      const cand = neighbors4(u.cell).find(c=>state.blocks.has(c));
      if(!cand){ toast('Aucun bloc adjacent.'); return; }
      state.blocks.delete(cand); log(`Bloc retirÃ© de ${cand}.`);
    }
    const idx = state.pieces[color].hand.findIndex(c=>c.type==='BLOCK_UNBLOCK'); if(idx>-1) commitCard(color, idx);
    renderAll();
  }

  // ---- Combat & dÃ©gÃ¢ts -----------------------------------------------------
  function rollAndApplyDamage(fromCell, targetUnit, targetColor){
    const roll = (Math.random()*6|0)+1;
    let dmg = (roll===1||roll===6)?2:1;
    if(state.weakenCritThisTurn && (roll===1||roll===6)) dmg=1;
    if(isFortCell(targetUnit.cell)){ }
    targetUnit.hp -= dmg;
    log(`Jet de dÃ© = ${roll} â†’ ${dmg} dÃ©gÃ¢t(s) sur ${targetColor==='blue'?'ðŸ”µ':'ðŸ”´'} ${targetUnit.id||'pion'}.`);
    if(targetUnit.hp<=0){ removeUnit(targetColor, targetUnit.id); }
    state.weakenCritThisTurn=false;
  }

  function isFortCell(c){ return c===FORT_BLUE || c===FORT_RED; }

  function removeUnit(color, id){
    const P=state.pieces[color];
    const idx = P.pieces.findIndex(u=>u.id===id);
    if(idx>-1){ P.pieces[idx].cell=null; P.pieces[idx].hp=2; log(`${color==='blue'?'ðŸ”µ':'ðŸ”´'} ${id} est retirÃ© du plateau.`); }
  }

  function piecesOf(color){ return state.pieces[color].pieces.filter(u=>u.cell); }

  function isAttackBlockedByImmunity(){
    if(!state.firstTurnMode) return false;
    return true;
  }

  // ---- Fin de tour & zone orange ------------------------------------------
  function endTurn(){
    const active = state.active; const opp = active==='blue'?'red':'blue';
    const countA = piecesOf(active).filter(u=>ORANGE.has(u.cell)).length;
    const countB = piecesOf(opp).filter(u=>ORANGE.has(u.cell)).length;
    let delta=0;
    if(countA>=3) delta=2; else if(countA>=2 && countB<=1) delta=1; else delta=0;
    if(delta>0){ state.pieces[opp].fortHP = Math.max(0, state.pieces[opp].fortHP - delta); log(`Zone orange: ${opp} perd ${delta} PV de forteresse.`); }

    if(state.drawTo4){ while(state.pieces[active].hand.length<4) draw(active,1); state.drawTo4=false; }
    else { drawUpTo5(active); }

    state.playedThisTurn=0; state.extraCardThisTurn=0; state.extraFreeMove=0; state.pressureThisTurn=false; state.noMagicThisTurn=false; state.disarmedThisTurn=false; state.weakenCritThisTurn=false;

    if(state.firstTurnMode){
      if(state.active===state.firstOrder){ state.immunity.p1=false; state.active = (state.firstOrder==='blue'?'red':'blue'); }
      else { state.immunity.p2=false; state.firstTurnMode=false; state.turn=1; state.active = state.firstOrder; }
    } else {
      state.active = (state.active==='blue'?'red':'blue');
      state.turn++;
    }

    state.phase='prÃ©paration'; renderAll();
  }

  // ---- ContrÃ´les UI --------------------------------------------------------
  $('#btnStart').addEventListener('click', ()=>{
    const rB = (Math.random()*6|0)+1; const rR = (Math.random()*6|0)+1;
    const first = rB===rR ? ((Math.random()<.5)?'blue':'red') : (rB>rR?'blue':'red');
    state.firstOrder = first; state.active = first; state.phase='actions';
    log(`Jet ðŸ”µ=${rB}, ðŸ”´=${rR}. ${first==='blue'?'Bleu':'Rouge'} commence. ImmunitÃ© active pour l'adversaire.`);
    renderAll();
  });

  $('#btnPlaceTiles').addEventListener('click', place47Tiles);
  $('#btnReset').addEventListener('click', initGame);
  $('#btnEndTurn').addEventListener('click', endTurn);

  initGame();

  </script>
</body>
</html>
