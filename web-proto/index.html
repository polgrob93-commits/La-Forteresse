<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>La Forteresse — Prototype final</title>
  <style>
    :root{ --grid:9; --bg:#0f1116; --panel:#151a23; --text:#e8eef7; --muted:#8ea0bf;
           --tile:#1b2230; --tile2:#1f2736; --orange:#e6a23c; --blue:#2c7be5; --red:#e55353; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(120deg,#0f1116,#0c111a);color:var(--text);
         font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .app{max-width:1240px;margin:14px auto;padding:0 12px;display:grid;gap:12px;
         grid-template-columns:300px 1fr 320px}
    .card{background:var(--panel);border:1px solid #232a3b;border-radius:16px;overflow:hidden;
          box-shadow:0 12px 28px rgba(0,0,0,.35)}
    .card h2{margin:0;padding:10px 12px;font-size:16px;border-bottom:1px solid #1e2533;background:#121722}
    .pad{padding:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .sep{height:1px;background:#20283b;margin:10px 0}
    .pill{display:inline-flex;align-items:center;gap:6px;background:#101827;border:1px solid #253045;
          border-radius:999px;padding:6px 10px}
    .btn{appearance:none;border:1px solid #2a3246;background:#192031;color:#cfe1ff;padding:8px 12px;border-radius:10px;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,#3563c9,#234db0);border-color:#2048a0;color:#fff;font-weight:600}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .log{height:220px;overflow:auto;font-family:ui-monospace,Menlo,Consolas,monospace;background:#111622;
         border-radius:10px;padding:10px;border:1px solid #222a3a}

    /* Board */
    .board-wrap{display:grid;place-items:center;padding:12px}
    #board{display:grid;grid-template-columns:repeat(9,1fr);grid-template-rows:repeat(9,1fr);
           gap:2px;width:96vmin;max-width:680px;aspect-ratio:1/1;background:#0b0f16;border:1px solid #1c2433;border-radius:14px;padding:8px}
    .cell{border-radius:8px;position:relative;display:grid;place-items:center;user-select:none}
    .cell.play{background:linear-gradient(180deg,var(--tile),var(--tile2));border:1px solid #24304a}
    .cell.invalid{background:transparent;border:1px dashed #1c2233;opacity:.25}
    .cell.orange{outline:2px solid var(--orange)}
    .cell.bzone{box-shadow:inset 0 0 0 2px rgba(44,123,229,.35)}
    .cell.rzone{box-shadow:inset 0 0 0 2px rgba(229,83,83,.35)}
    .coord{position:absolute;right:4px;bottom:4px;font-size:10px;color:#8a94ab;opacity:.7}

    /* Highlight classes */
    .cell.hl { outline:3px solid #fff; outline-offset:-3px; }
    .cell.move-ok { box-shadow:inset 0 0 0 3px rgba(111, 255, 145, .9); cursor:pointer; }
    .cell.move-bad{ box-shadow:inset 0 0 0 3px rgba(255, 111, 111, .7); }
    .cell.target-ok{ box-shadow:inset 0 0 0 3px rgba(255, 215, 111, .9); cursor:pointer; }

    /* blocks: small brown circles */
    .block{width:40%;height:40%;border-radius:50%;background:linear-gradient(180deg,#5a4a3f,#3e3028);}

    /* Pieces, forts, blocks */
    .piece, .fort, .block{display:grid;place-items:center;font-weight:700;color:#0b0f16;border:2px solid rgba(0,0,0,.35);box-shadow:0 6px 12px rgba(0,0,0,.35)}
    .piece{width:70%;height:70%;border-radius:50%}
    .fort{width:80%;height:80%;border-radius:12px;font-weight:800}
    .piece.blue{background:linear-gradient(180deg,#3c9cff,#2c7be5)}
    .piece.red{background:linear-gradient(180deg,#ff6767,#e55353)}
    .fort.blue{background:linear-gradient(180deg,#afd3ff,#7ab6ff)}
    .fort.red{background:linear-gradient(180deg,#ffb1b1,#ff7e7e)}
    .hp{position:absolute;bottom:-10px;left:50%;transform:translateX(-50%);font-size:11px;color:#cfd7ea;background:#121722;border:1px solid #1d2433;border-radius:8px;padding:2px 6px}

    .hand{display:grid;gap:8px}
    .cardui{background:#141a22;border:1px solid #232a3a;border-radius:12px;padding:10px}
    .cardui h4{margin:0 0 6px;font-size:13px}
    .small{font-size:11px;color:var(--muted)}
    .playbtn{margin-top:8px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  </style>
</head>
<body>

  <div class="app">
    <aside class="card">
      <h2>État de la partie</h2>
      <div class="pad">
        <div class="row" style="justify-content:space-between">
          <div class="pill"><strong>Tour:</strong> <span id="turnLabel">0</span></div>
          <button id="btnStart" class="btn primary" style="display:none">Déterminer le 1er joueur</button>
          <button id="btnReadyBlue" class="btn">Prêt 🔵</button>
          <button id="btnReadyRed" class="btn">Prêt 🔴</button>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Forteresse 🔵</h4>
            <div>PV: <span id="blueHP">7</span> (A9)</div>
          </div>
          <div class="cardui">
            <h4>Forteresse 🔴</h4>
            <div>PV: <span id="redHP">7</span> (I1)</div>
          </div>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Phase</h4>
            <div id="phase" class="small">préparation</div>
          </div>
          <div class="cardui">
            <h4>Immunité (tour 1)</h4>
            <div class="small">J1: <span id="im1">✔</span> · J2: <span id="im2">✔</span></div>
          </div>
        </div>
      <div class="sep"></div>
      <!-- Affichage du nombre de cartes jouées ce tour -->
      <div class="cardui">
        <h4>Cartes jouées</h4>
        <div class="small" id="cardsPlayed">0/3</div>
      </div>
        <div class="sep"></div>
        <div class="cardui">
          <h4>Actions rapides</h4>
          <div class="row">
            <button class="btn" id="btnPlaceTiles">Placer 47 tuiles</button>
            <button class="btn" id="btnReset">Réinitialiser</button>
          </div>
        </div>
        <div class="sep"></div>
        <div class="cardui">
          <h4>Journal</h4>
          <div id="log" class="log"></div>
        </div>
      </div>
    </aside>

    <main class="card">
      <h2>Plateau</h2>
      <div class="board-wrap">
        <div id="board"></div>
      </div>
    </main>

    <aside class="card">
      <h2>Main & Pioches</h2>
      <div class="pad">
        <div class="row" style="justify-content:space-between">
          <div class="pill">Joueur actif: <strong id="activePlayer">—</strong></div>
          <button id="btnEndTurn" class="btn">Fin de tour</button>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Main (🔵)</h4>
            <div id="handBlue" class="hand"></div>
          </div>
          <div class="cardui">
            <h4>Main (🔴)</h4>
            <div id="handRed" class="hand"></div>
          </div>
        </div>
        <div class="sep"></div>
        <div class="grid3">
          <div class="cardui">
            <h4>Pioches</h4>
            <div class="small">🔵: <span id="deckB">—</span> · 🔴: <span id="deckR">—</span></div>
            <div class="small">Défausses — 🔵: <span id="discB">0</span> · 🔴: <span id="discR">0</span></div>
          </div>
          <div class="cardui">
            <h4>Tuiles</h4>
            <div class="small">Placées: <span id="tilesCount">0</span> / 47</div>
          </div>
          <div class="cardui">
            <h4>Blocs</h4>
            <div class="small"><span id="blocksActive">0</span> / 6</div>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <script>
  // ===== Constantes plateau =====
  const GRID=9, COLS="ABCDEFGHI";
  const forbidden = new Set(["A1","B1","C1","A2","B2","C2","A3","B3","G9","H9","I9","G8","H8","I8","H7","I7"]);
  const valid = new Set([
    "A4","A5","A6","A7","A8",
    "B4","B5","B6","B7","B8","B9",
    "C3","C4","C5","C6","C7","C8","C9",
    "D1","D2","D3","D4","D5","D6","D7","D8","D9",
    "E1","E2","E3","E4","E5","E6","E7","E8","E9",
    "F1","F2","F3","F4","F5","F6","F7","F8","F9",
    "G1","G2","G3","G4","G5","G6","G7",
    "H1","H2","H3","H4","H5","H6",
    "I2","I3","I4","I5","I6"
  ]);
  const ORANGE = new Set(["D5","E4","E5","E6","F5"]);
  const RED_SPAWN = new Set(["G1","G2","G3","H1","H2","H3","I2","I3"]);
  const BLUE_SPAWN= new Set(["A8","A7","B9","B8","B7","C9","C8","C7"]);
  const FORT_BLUE="A9", FORT_RED="I1";

  const $ = (s)=>document.querySelector(s);
  const board=$("#board"), logEl=$("#log");

  const state = {
    turn:0, active:'blue', phase:'préparation',
    firstTurnMode:true, firstOrder:null, immunity:{p1:true,p2:true},
    blocks:new Set(),
    tiles:{}, // cell -> {key,kind,revealed}
    selected:null,
    played:0,
    freeMoveRemaining:0,
    inProgress:null, // {mode:'MOVE', color, unitId, cardId, remaining}
    discardLeft:0, // number of cards the player may still discard in the preparation phase
    // NEW: track setup phase for initial placement (mode: 'blue' or 'red'; placed count; done)
    setup:{ done:false, blue:{placed:0, ready:false, selected:null}, red:{placed:0, ready:false, selected:null} },
    pieces:{
      blue:{fortHP:7, pieces:[], hand:[], deck:[], discard:[]},
      red :{fortHP:7, pieces:[], hand:[], deck:[], discard:[]},
    },
    flags:{} // e.g. extraCard, drawTo4, noMagic, etc.
    ,
    forcedDiscard:null,

    // === Tiles reveal tracking ===
    // Each player may reveal at most one tile per turn. After a tile is revealed
    // this flag is set for the player until endTurn resets it.
    tileRevealedThisTurn: { blue:false, red:false },
    // When a unit finishes a movement (free or card), we store the context here.  
    // { color, unitId, from, to, kind }
    lastLanding: null
  };

  // ===== Helpers =====
  function toAlg(c,r){ return COLS[c]+(r+1); }
  function fromAlg(a){ return {c:COLS.indexOf(a[0]), r:+a.slice(1)-1}; }
  function log(t){ const p=document.createElement('div'); p.textContent=t; logEl.appendChild(p); logEl.scrollTop=logEl.scrollHeight; }
  function neighbors4(a){ const {c,r}=fromAlg(a); const outs=[]; [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dc,dr])=>{ const nc=c+dc, nr=r+dr; if(nc>=0&&nc<GRID&&nr>=0&&nr<GRID){ const x=toAlg(nc,nr); if(!forbidden.has(x)) outs.push(x); }}); return outs; }
  function isAdjacent4(a,b){ return neighbors4(a).includes(b); }
  function isLine(a,b){
    const A=fromAlg(a), B=fromAlg(b); const dc=Math.sign(B.c-A.c), dr=Math.sign(B.r-A.r);
    if(!(A.c===B.c || A.r===B.r || Math.abs(B.c-A.c)===Math.abs(B.r-A.r))) return null;
    const seq=[]; let c=A.c+dc, r=A.r+dr; while(!(c===B.c && r===B.r)){ seq.push(toAlg(c,r)); c+=dc; r+=dr; } return seq;
  }
  function isFortCell(cell){ return cell===FORT_BLUE || cell===FORT_RED; }
  function isLOS(a,b){ const between=isLine(a,b); if(!between) return false;
    return between.every(c=>!state.blocks.has(c) && !getPieceAt(c) && !isFortCell(c));
  }
  function getPieceAt(cell){
    // Exclude fort positions; forts are handled separately
    if(isFortCell(cell)) return null;
    for(const color of ['blue','red']){
      const u=state.pieces[color].pieces.find(p=>p.cell===cell);
      if(u) return {color,unit:u};
    }
    return null;
  }
  function findUnit(color,id){ return state.pieces[color].pieces.find(u=>u.id===id); }
  function canStep(from,to){
    if(!from||from===to) return false;
    if(isFortCell(to)) return false;
    if(!valid.has(to)||state.blocks.has(to)||getPieceAt(to)) return false;
    return isAdjacent4(from,to);
  }

  // NEW: check if a spawn cell is free for a pion (no fort, no block, no other pion)
  function spawnCellFree(color, cell){
    if(isFortCell(cell)) return false;
    if(state.blocks.has(cell)) return false;
    if(getPieceAt(cell)) return false;
    return true;
  }

  // ===== Board build =====
  function buildGrid(){
    board.innerHTML='';
    for(let r=GRID-1;r>=0;r--){
      for(let c=0;c<GRID;c++){
        const alg=toAlg(c,r);
        const cell=document.createElement('div'); cell.className='cell '+(forbidden.has(alg)?'invalid':'play'); cell.dataset.coord=alg;
        if(ORANGE.has(alg)) cell.classList.add('orange');
        if(RED_SPAWN.has(alg)) cell.classList.add('rzone');
        if(BLUE_SPAWN.has(alg)) cell.classList.add('bzone');
        const q=document.createElement('div'); q.className='coord'; q.textContent=alg; cell.appendChild(q);
        cell.addEventListener('click', () => onCellClick(alg, cell));
        board.appendChild(cell);
      }
    }
  }

  function renderBoard(){
    // Clear and re-render pieces, forts, blocks
    document.querySelectorAll('.cell').forEach(cell=>{
      // remove non-coord children
      [...cell.children].forEach(ch=>{ if(!ch.classList.contains('coord')) ch.remove(); });
      // update block state visually
      cell.classList.toggle('blocked', state.blocks.has(cell.dataset.coord));
    });
    // Forts
    const fortPositions=[[FORT_BLUE,'blue',state.pieces.blue.fortHP],[FORT_RED,'red',state.pieces.red.fortHP]];
    fortPositions.forEach(([pos,color,hp])=>{
      const cell=document.querySelector(`.cell[data-coord="${pos}"]`);
      if(cell){ const f=document.createElement('div'); f.className=`fort ${color}`; f.textContent='F';
        const h=document.createElement('div'); h.className='hp'; h.textContent=`${hp} PV`;
        cell.appendChild(f); cell.appendChild(h);
      }
    });
    // Blocks
    state.blocks.forEach(pos=>{
      const cell=document.querySelector(`.cell[data-coord="${pos}"]`);
      if(cell){ const b=document.createElement('div'); b.className='block'; cell.appendChild(b); }
    });
    // Pieces
    ['blue','red'].forEach(color=>{
      state.pieces[color].pieces.forEach(u=>{
        if(!u.cell) return;
        const cell=document.querySelector(`.cell[data-coord="${u.cell}"]`);
        if(cell){ const p=document.createElement('div'); p.className=`piece ${color}`; p.textContent=u.hp;
          p.title=`${color} ${u.id}`;
          cell.appendChild(p);
        }
      });
    });
    // Apply highlights for move/free move
    applyHighlights();
  }

  // ===== Decks & hands =====
  function buildDeck26(){
    const deck=[];
    deck.push(...Array(3).fill({t:'MOVE',n:2}));
    deck.push(...Array(3).fill({t:'MOVE',n:3}));
    deck.push(...Array(2).fill({t:'MOVE',n:4}));
    deck.push(...Array(2).fill({t:'MOVE',n:5}));
    deck.push(...Array(6).fill({t:'MELEE_SWAP'}));
    deck.push(...Array(4).fill({t:'RANGE_TP'}));
    deck.push(...Array(3).fill({t:'HEAL_REINFORCE'}));
    deck.push(...Array(3).fill({t:'BLOCK_UNBLOCK'}));
    return deck.map((c,i)=>({...c,id:`C${Math.random().toString(36).slice(2,8)}${i}`}));
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function reshuffleIfNeeded(P){ if(P.deck.length===0 && P.discard.length){ P.deck=shuffle(P.discard.splice(0)); log('🔄 Re-mélange de la défausse dans la pioche.'); } }
  function draw(color,n){ const P=state.pieces[color]; while(n-->0){ if(P.deck.length===0) reshuffleIfNeeded(P); if(P.deck.length===0) break; P.hand.push(P.deck.pop()); } updateDeckUI(); }
  function drawTo(color,cap){ const P=state.pieces[color]; while(P.hand.length<cap){ if(P.deck.length===0) reshuffleIfNeeded(P); if(P.deck.length===0) break; P.hand.push(P.deck.pop()); } updateDeckUI(); }
  function updateDeckUI(){
    // Update deck display to show remaining / total (deck + hand + discard)
    const blueTotal = state.pieces.blue.deck.length + state.pieces.blue.hand.length + state.pieces.blue.discard.length;
    const redTotal  = state.pieces.red.deck.length  + state.pieces.red.hand.length  + state.pieces.red.discard.length;
    $('#deckB').textContent = `${state.pieces.blue.deck.length} / ${blueTotal}`;
    $('#deckR').textContent = `${state.pieces.red.deck.length} / ${redTotal}`;
    $('#discB').textContent=state.pieces.blue.discard.length;
    $('#discR').textContent=state.pieces.red.discard.length;
  }
  function renderHands(){
    function side(color,target){
      const force = (state.forcedDiscard && state.forcedDiscard.color===color && state.forcedDiscard.remaining>0);
      const P=state.pieces[color]; target.innerHTML='';
      P.hand.forEach((card,idx)=>{
        const box=document.createElement('div'); box.className='cardui';
        const h=document.createElement('h4');
        switch(card.t){ case 'MOVE': h.textContent=`Déplacement ${card.n}`; break;
          case 'MELEE_SWAP': h.textContent='CAC / Échange'; break;
          case 'RANGE_TP': h.textContent='Attaque à distance / Téléportation'; break;
          case 'HEAL_REINFORCE': h.textContent='Soin / Renfort'; break;
          case 'BLOCK_UNBLOCK': h.textContent='Blocage / Déblocage'; break;
          default: h.textContent='Carte'; }
        box.appendChild(h);
        const s=document.createElement('div'); s.className='small'; s.textContent='#'+card.id; box.appendChild(s);
        // Limite de cartes jouées (utilisée pour l'activation des boutons)
        const limit = 3 + (state.flags.extraCard ? state.flags.extraCard : 0);
        // Fonction utilitaire pour savoir si on peut jouer une carte
        function isActionDisabled(){
          return state.phase !== 'actions' || state.active!==color || state.played >= limit || state.gameOver;
        }
        if(card.t === 'MOVE'){
          // Bouton unique pour jouer une carte déplacement
          const btn=document.createElement('button'); btn.className='btn playbtn'; btn.textContent='Jouer';
          btn.disabled = isActionDisabled() || force;
          btn.addEventListener('click', ()=> playCard(color, idx));
          box.appendChild(btn);
          // si cette carte est un déplacement en cours, proposer un bouton Défausser/Annuler
          if(state.inProgress && state.inProgress.mode==='MOVE' && state.inProgress.cardId===card.id && !state.gameOver){
            const cancelBtn=document.createElement('button'); cancelBtn.className='btn playbtn'; cancelBtn.style.marginTop='4px';
            cancelBtn.textContent = (state.inProgress.remaining === state.inProgress.initial) ? 'Annuler' : 'Défausser';
            cancelBtn.addEventListener('click', ()=>{
              if(state.inProgress && state.inProgress.remaining === state.inProgress.initial){
                // Aucun pas n'a été effectué : annuler simplement la carte
                cancelMoveCard();
              } else {
                // Des pas ont été utilisés : commit la carte et révéler la tuile
                commitMoveInProgress();
                triggerTileAtEndIfAny();
              }
              renderBoard();
            });
            box.appendChild(cancelBtn);
          }
        } else if(card.t === 'MELEE_SWAP'){
          // Deux boutons: attaque CAC et Échange
          const btnMelee=document.createElement('button'); btnMelee.className='btn playbtn'; btnMelee.textContent='CAC';
          btnMelee.disabled = isActionDisabled() || force;
          btnMelee.addEventListener('click', ()=> playMelee(color, idx));
          const btnSwap=document.createElement('button'); btnSwap.className='btn playbtn'; btnSwap.style.marginLeft='4px'; btnSwap.textContent='Échange';
          btnSwap.disabled = isActionDisabled() || force;
          btnSwap.addEventListener('click', ()=> playSwap(color, idx));
          box.appendChild(btnMelee); box.appendChild(btnSwap);
        } else if(card.t === 'RANGE_TP'){
          // Deux boutons: attaque à distance et téléportation
          const btnRange=document.createElement('button'); btnRange.className='btn playbtn'; btnRange.textContent='DIST';
          btnRange.disabled = isActionDisabled() || force;
          btnRange.addEventListener('click', ()=> playRangeAttack(color, idx));
          const btnTP=document.createElement('button'); btnTP.className='btn playbtn'; btnTP.style.marginLeft='4px'; btnTP.textContent='TP';
          btnTP.disabled = isActionDisabled() || force;
          btnTP.addEventListener('click', ()=> playTeleport(color, idx));
          box.appendChild(btnRange); box.appendChild(btnTP);
        } else if(card.t === 'HEAL_REINFORCE'){
          // Deux boutons: soin (immédiat) et renfort (placement)
          const btnHeal=document.createElement('button'); btnHeal.className='btn playbtn'; btnHeal.textContent='SOIN';
          btnHeal.disabled = isActionDisabled() || force;
          btnHeal.addEventListener('click', ()=> playHeal(color, idx));
          const btnReinf=document.createElement('button'); btnReinf.className='btn playbtn'; btnReinf.style.marginLeft='4px'; btnReinf.textContent='RENF';
          btnReinf.disabled = isActionDisabled() || force;
          btnReinf.addEventListener('click', ()=> playReinforce(color, idx));
          box.appendChild(btnHeal); box.appendChild(btnReinf);
        } else if(card.t === 'BLOCK_UNBLOCK'){
          // Deux boutons: blocage et déblocage
          const btnBlock=document.createElement('button'); btnBlock.className='btn playbtn'; btnBlock.textContent='BLOC';
          btnBlock.disabled = isActionDisabled() || force;
          btnBlock.addEventListener('click', ()=> playBlock(color, idx));
          const btnUnblock=document.createElement('button'); btnUnblock.className='btn playbtn'; btnUnblock.style.marginLeft='4px'; btnUnblock.textContent='DEBLOC';
          btnUnblock.disabled = isActionDisabled() || force;
          btnUnblock.addEventListener('click', ()=> playUnblock(color, idx));
          box.appendChild(btnBlock); box.appendChild(btnUnblock);
        } else {
          // Cas par défaut: bouton Jouer
          const btn=document.createElement('button'); btn.className='btn playbtn'; btn.textContent='Jouer';
          btn.disabled = isActionDisabled() || force;
          btn.addEventListener('click', ()=> playCard(color, idx));
          box.appendChild(btn);
        }
        // En phase de préparation, proposer un bouton Défausser pour chaque carte tant qu'il reste des défausses
        if(state.phase === 'préparation' && state.active === color && state.discardLeft > 0 && !state.inProgress && !state.gameOver){
          const discardBtn=document.createElement('button'); discardBtn.className='btn playbtn'; discardBtn.style.marginTop='4px'; discardBtn.textContent='Défausser';
          discardBtn.addEventListener('click', ()=>{
            const P=state.pieces[color]; const cardIndex=P.hand.findIndex(c=>c.id===card.id);
            if(cardIndex>=0){ const [c]=P.hand.splice(cardIndex,1); if(c) P.discard.push(c); }
            state.discardLeft--;
            renderHands(); updateDeckUI();
          });
          box.appendChild(discardBtn);
        }
        if(force){
          const fbtn=document.createElement('button'); fbtn.className='btn playbtn'; fbtn.style.marginTop='4px'; fbtn.textContent='Défausser (obligatoire)';
          fbtn.addEventListener('click', ()=>{
            const P=state.pieces[color]; const cardIndex=P.hand.findIndex(c=>c.id===card.id);
            if(cardIndex>=0){ const [c]=P.hand.splice(cardIndex,1); if(c) P.discard.push(c); }
            if(state.forcedDiscard && state.forcedDiscard.color===color){
              state.forcedDiscard.remaining--;
              if(state.forcedDiscard.remaining<=0){ state.forcedDiscard=null; }
            }
            updateDeckUI(); renderHands();
          });
          box.appendChild(fbtn);
        }
        if(force){
          const fbtn=document.createElement('button'); fbtn.className='btn playbtn'; fbtn.style.marginTop='4px'; fbtn.textContent='Défausser (obligatoire)';
          fbtn.addEventListener('click', ()=>{
            const P=state.pieces[color]; const cardIndex=P.hand.findIndex(c=>c.id===card.id);
            if(cardIndex>=0){ const [c]=P.hand.splice(cardIndex,1); if(c) P.discard.push(c); }
            if(state.forcedDiscard && state.forcedDiscard.color===color){
              state.forcedDiscard.remaining--;
              if(state.forcedDiscard.remaining<=0){ state.forcedDiscard=null; }
            }
            updateDeckUI(); renderHands();
          });
          box.appendChild(fbtn);
        }
        target.appendChild(box);
      });
    }
    side('blue', $('#handBlue')); side('red', $('#handRed'));
  }

  // ===== Highlights =====
  function clearHighlights(){ document.querySelectorAll('.cell').forEach(cell=>{
    cell.classList.remove('move-ok','move-bad','hl','target-ok'); }); }
  function applyHighlights(){
    clearHighlights();
    // NEW: during setup (initial placement), highlight spawn cells for current color
    if(!state.setup.done){
      // highlight both spawn zones for empty cells
      [['blue', BLUE_SPAWN], ['red', RED_SPAWN]].forEach(([color, spawn])=>{
        spawn.forEach(coord=>{
          if(spawnCellFree(color, coord)){
            const cell = document.querySelector(`.cell[data-coord="${coord}"]`);
            if(cell) cell.classList.add('target-ok');
          }
        });
      });
      return;
    }
    // highlight selected unit
    if(state.selected){
      const cell = document.querySelector(`.cell[data-coord="${state.selected.cell}"]`);
      if(cell) cell.classList.add('hl');
    }
    // highlight for actions in progress
    if(state.inProgress){
      if(state.inProgress.mode === 'MOVE'){
        const {color, unitId} = state.inProgress;
        const unit = findUnit(color, unitId);
        if(unit && unit.cell){
          neighbors4(unit.cell).forEach(coord=>{
            const cell = document.querySelector(`.cell[data-coord="${coord}"]`);
            if(!cell) return;
            if(canStep(unit.cell,coord)) cell.classList.add('move-ok');
            else cell.classList.add('move-bad');
          });
          const here = document.querySelector(`.cell[data-coord="${unit.cell}"]`);
          if(here) here.classList.add('hl');
        }
        return;
      }
      if(state.inProgress.mode === 'BLOCK'){
        // highlight candidates for block placement
        state.inProgress.candidates.forEach(coord=>{
          const cell = document.querySelector(`.cell[data-coord="${coord}"]`);
          if(cell) cell.classList.add('target-ok');
        });
        // highlight selected unit
        const u = findUnit(state.inProgress.color, state.inProgress.unitId);
        if(u && u.cell){
          const cell = document.querySelector(`.cell[data-coord="${u.cell}"]`);
          if(cell) cell.classList.add('hl');
        }
        return;
      }
      // Autres modes ciblés (MELEE, SWAP, RANGE, TP, TILE_HEAL1, TILE_WHEEL)
      if(state.inProgress.mode === 'MELEE' || state.inProgress.mode === 'SWAP' || state.inProgress.mode === 'RANGE' || state.inProgress.mode === 'TP' || state.inProgress.mode === 'TILE_HEAL1' || state.inProgress.mode === 'TILE_WHEEL'){
        state.inProgress.candidates.forEach(coord => {
          const cell = document.querySelector(`.cell[data-coord="${coord}"]`);
          if(cell) cell.classList.add('target-ok');
        });
        // pour MELEE/SWAP/RANGE/TP, surligner l'unité à l'origine si disponible
        if(state.inProgress.unitId){
          const u = findUnit(state.inProgress.color, state.inProgress.unitId);
          if(u && u.cell){
            const cell = document.querySelector(`.cell[data-coord="${u.cell}"]`);
            if(cell) cell.classList.add('hl');
          }
        }
        return;
      }
      if(state.inProgress.mode === 'RENF'){
        // highlight spawn cells for reinforcements
        const color = state.inProgress.color;
        const spawn = color === 'blue' ? BLUE_SPAWN : RED_SPAWN;
        spawn.forEach(coord=>{
          if(spawnCellFree(color, coord)){
            const cell = document.querySelector(`.cell[data-coord="${coord}"]`);
            if(cell) cell.classList.add('target-ok');
          }
        });
        return;
      }
    }
    // highlight for free move if available
    if(state.selected && state.freeMoveRemaining > 0){
      const unit = findUnit(state.selected.color, state.selected.id);
      if(unit && unit.cell){
        neighbors4(unit.cell).forEach(coord=>{
          const cell = document.querySelector(`.cell[data-coord="${coord}"]`);
          if(!cell) return;
          if(canStep(unit.cell,coord)) cell.classList.add('move-ok');
          else cell.classList.add('move-bad');
        });
        const here = document.querySelector(`.cell[data-coord="${unit.cell}"]`);
        if(here) here.classList.add('hl');
      }
    }
  }

  // ===== Game init =====
  function initGame(){
    Object.assign(state,{
      turn:0, active:'blue', phase:'préparation',
      firstTurnMode:true, firstOrder:null, immunity:{p1:true,p2:true},
      blocks:new Set(), tiles:{}, selected:null, played:0, flags:{}, freeMoveRemaining:0, inProgress:null,
      discardLeft:0,
      gameOver:false,
      // Reset tile reveal quota and landing context
      tileRevealedThisTurn:{blue:false, red:false},
      lastLanding:null
    });
    state.pieces.blue={fortHP:7, pieces:[], hand:[], deck:shuffle(buildDeck26()), discard:[]};
    state.pieces.red ={fortHP:7, pieces:[], hand:[], deck:shuffle(buildDeck26()), discard:[]};
    // build 7 pions per color in reserve (no initial placement)
    state.pieces.blue.pieces = [];
    state.pieces.red.pieces  = [];
    for(let i=1; i<=7; i++){
      state.pieces.blue.pieces.push({id:`B${i}`, cell:null, hp:2});
      state.pieces.red.pieces.push({id:`R${i}`, cell:null, hp:2});
    }
    // initialize setup phase: blue places first, 5 pions each
    state.setup = {done:false, blue:{placed:0, ready:false, selected:null}, red:{placed:0, ready:false, selected:null}};
    // draw initial hands
    drawTo('blue',5); drawTo('red',5);
    // build grid and render
    buildGrid(); renderBoard(); renderHands(); renderTop();
    log('Nouvelle partie. Placez 5 pions bleus, puis 5 pions rouges en cliquant dans les zones en surbrillance. Ensuite placez 47 tuiles et tirez le premier joueur.');
  }

  // ===== Tiles =====
  function place47(){
    // Place 47 tiles drawn from a bag of 81 predefined tiles (mix of positive, negative and blank)
    // Determine eligible cells (no spawn zones, no forts)
    const all=[...valid].filter(c=>!RED_SPAWN.has(c)&&!BLUE_SPAWN.has(c)&&c!==FORT_BLUE&&c!==FORT_RED);
    const spots=shuffle(all).slice(0,47);
    // Build the bag of 81 tiles according to distribution
    const bag=[
      // Positives (25)
      ...Array(5).fill({key:'ANCHOR', kind:'anchor'}),
      ...Array(4).fill({key:'REFLEX', kind:'reflex'}),
      ...Array(6).fill({key:'SPRINT', kind:'sprint'}),
      ...Array(4).fill({key:'PRESS',  kind:'pressure'}),
      ...Array(4).fill({key:'BANDAGE',kind:'bandage'}),
      ...Array(2).fill({key:'WHEEL',  kind:'wheel'}),
      // Negatives (16)
      ...Array(3).fill({key:'SNAG',    kind:'snag'}),
      ...Array(2).fill({key:'ANTIMAG', kind:'antimagic'}),
      ...Array(4).fill({key:'HEAVY',   kind:'heavy'}),
      ...Array(3).fill({key:'DISARM',  kind:'disarmed'}),
      ...Array(2).fill({key:'WEAK',    kind:'weak'}),
      ...Array(2).fill({key:'REVERSE', kind:'reverse'}),
      // Blanks (40)
      ...Array(40).fill({key:'BLANK',  kind:'blank'})
    ];
    // Shuffle the bag and pick the first 47
    const pool=shuffle(bag).slice(0,47);
    state.tiles={};
    spots.forEach((cell,i)=>{
      const def=pool[i];
      state.tiles[cell]={ key:def.key, kind:def.kind, revealed:false };
    });
    updateTilesUI(); log('47 tuiles placées (sac de 81).');
  }
  function updateTilesUI(){ $('#tilesCount').textContent=Object.keys(state.tiles).length; }
  // Provide a human-readable label for a tile
  function tileLabel(t){
    const labels={
      anchor:'Tir ancré',
      reflex:'Réflexe',
      sprint:'Sprint',
      pressure:'Pression',
      bandage:'Pansement',
      wheel:'Molette',
      snag:'Accroc',
      antimagic:'Anti-magie',
      heavy:'Main lourde',
      disarmed:'Désarmé',
      weak:'Faiblesse',
      reverse:'Reverse',
      blank:'Sans effet'
    };
    return labels[t.kind] || t.key || '—';
  }
  function revealTileIfAny(cell,color){
    const t=state.tiles[cell]; if(!t || t.revealed) return;
    t.revealed=true; log(`[Tuile] Révélée sur ${cell} (sans effet pour l'instant)`);
    updateTilesUI();
  }

  // === Tile reveal at end of movement ===
  // When a unit finishes a movement (card, free move, teleport or swap) and we haven't
  // already revealed a tile this turn for that player, check if the landing cell has a
  // hidden tile, reveal it and apply its effect. The tile is removed from the board.
  function triggerTileAtEndIfAny(){
    const info = state.lastLanding;
    if(!info) return;
    const {color, to} = info;
    // Only one tile per player per turn
    if(state.tileRevealedThisTurn[color]) return;
    // Tiles under a block are not revealed
    if(state.blocks.has(to)) return;
    const t = state.tiles[to];
    if(!t || t.revealed) return;
    t.revealed = true;
    state.tileRevealedThisTurn[color] = true;
    log(`[Tuile] Révélée en ${to} → ${tileLabel(t)}.`);
    // Apply the tile effect immediately (some effects will set up an inProgress mode)
    applyTileEffect(to, color, t);
    // Remove the tile from play
    delete state.tiles[to];
    updateTilesUI();
  }

  // === Apply tile effects ===
  function applyTileEffect(cell, color, t){
    const enemy = (color === 'blue' ? 'red' : 'blue');
    switch(t.kind){
      // ----- Positives -----
      case 'anchor': {
        if(state.flags.disarmed){ draw(color,1); promptDiscard(color,1); log('Tir ancré : désarmé — pioche 1, défausse 1.'); return; }
        // Tir ancré : effectuer une attaque à distance gratuite depuis cette case.
        // Trouver un tireur : le pion qui vient d'atterrir sur la tuile.
        const u = state.pieces[color].pieces.find(p => p.cell === cell);
        if(!u){
          // Aucun pion dessus → rien
          draw(color,1);
          promptDiscard(color,1);
          log('Tir ancré : aucune cible — pioche 1, défausse 1.');
          return;
        }
        // Déterminer les cibles possibles (portée DIST, LOS, non adjacente)
        const cands = [];
        const shooter = u;
        // Fort ennemi
        const enemyFort = (color === 'blue' ? FORT_RED : FORT_BLUE);
        if(!isAdjacent4(shooter.cell, enemyFort) && isLOS(shooter.cell, enemyFort)){
          const A = fromAlg(shooter.cell);
          const B = fromAlg(enemyFort);
          const dx = Math.abs(A.c - B.c), dy = Math.abs(A.r - B.r);
          const ortho = (dx === 0 || dy === 0) && (dx + dy >= 2 && dx + dy <= 4);
          const diag  = (dx === dy) && (dx >= 1 && dx <= 2);
          if(ortho || diag) cands.push(enemyFort);
        }
        // Pions ennemis
        state.pieces[enemy].pieces.forEach(p => {
          if(!p.cell) return;
          if(isAdjacent4(shooter.cell, p.cell)) return;
          if(!isLOS(shooter.cell, p.cell)) return;
          const A = fromAlg(shooter.cell);
          const B = fromAlg(p.cell);
          const dx = Math.abs(A.c - B.c), dy = Math.abs(A.r - B.r);
          const ortho = (dx === 0 || dy === 0) && (dx + dy >= 2 && dx + dy <= 4);
          const diag  = (dx === dy) && (dx >= 1 && dx <= 2);
          if(ortho || diag) cands.push(p.cell);
        });
        if(cands.length === 0){
          // Pas de cible : pioche et défausse 1
          draw(color,1);
          promptDiscard(color,1);
          log('Tir ancré : aucune cible — pioche 1, défausse 1.');
        } else {
          // Mettre en place une attaque à distance gratuite (pas de carte à défausser)
          state.inProgress = { mode:'RANGE', color, unitId: shooter.id, cardId: null, candidates: cands };
          applyHighlights();
          log('Tir ancré : choisissez une cible à distance.');
        }
        return;
      }
      case 'reflex': {
        // Réflexe : pioche 1 et +1 carte jouable ce tour (plafond +1)
        draw(color,1);
        if(!state.flags.extraCard) state.flags.extraCard = 0;
        state.flags.extraCard = Math.min(1, state.flags.extraCard + 1);
        log('Réflexe : +1 carte en main et +1 carte jouable ce tour.');
        return;
      }
      case 'sprint': {
        // Sprint : +2 cases à votre déplacement gratuit ce tour
        state.freeMoveRemaining += 2;
        log('Sprint : +2 cases à votre déplacement gratuit ce tour.');
        return;
      }
      case 'pressure': {
        // Pression : la prochaine attaque que vous déclarez oblige l'adversaire à défausser 1 avant la résolution
        state.flags.pressure = true;
        log('Pression : la prochaine attaque obligera l’adversaire à défausser 1.');
        return;
      }
      case 'bandage': {
// Pansement : soignez +1 PV un de vos pions BLESSÉ (1 PV) ou votre forteresse
// Préparer ciblage : fort allié + seulement les pions à 1 PV
const cands = [];
const fortCoord = (color === 'blue' ? FORT_BLUE : FORT_RED);
cands.push(fortCoord);
state.pieces[color].pieces.forEach(p => { if(p.cell && (p.hp || 0) < 2) cands.push(p.cell); });
state.inProgress = { mode:'TILE_HEAL1', color, candidates: cands };
applyHighlights();
log('Pansement : choisissez une cible à soigner (+1 PV). (Uniquement pions à 1 PV ou forteresse)');

        return;
      }
      case 'wheel': {
        // Molette : placez ou retirez un bloc n’importe où (hors spawn zones, orange, forts)
        const cands = [];
        valid.forEach(coord => {
          if(isFortCell(coord) || ORANGE.has(coord) || RED_SPAWN.has(coord) || BLUE_SPAWN.has(coord)) return;
          // Permettre la case même si un bloc est déjà là : on retirera
          cands.push(coord);
        });
        state.inProgress = { mode:'TILE_WHEEL', color, candidates: cands };
        applyHighlights();
        log('Molette : cliquez pour placer ou retirer un bloc (max 6 blocs).');
        return;
      }
      // ----- Negatives -----
      case 'snag': {
        // Accroc : à la fin de ce tour, le joueur piochera jusqu’à 4 cartes
        state.flags.drawTo4 = true;
        log('Accroc : en fin de tour vous ne piocherez que jusqu’à 4 cartes.');
        return;
      }
      case 'antimagic': {
        // Anti-magie : le pion qui a déclenché la tuile ne peut pas téléporter ou échanger jusqu’à la fin du tour
        const occ = getPieceAt(cell);
        if(occ){ occ.unit.noMagic = true; log('Anti-magie : ce pion ne peut pas se téléporter/échanger ce tour.'); }
        return;
      }
      case 'heavy': {
        // Main lourde : la prochaine attaque (1 ou 6) infligera 1 dégât au lieu de 2
        state.flags.weakenCrit = true;
        log('Main lourde : la prochaine attaque critique infligera 1 dégât.');
        return;
      }
      case 'disarmed': {
        // Désarmé : vous ne pouvez pas déclarer d’attaque ce tour
        state.flags.disarmed = true;
        log('Désarmé : vous ne pouvez pas attaquer ce tour.');
        return;
      }
      case 'weak': {
        // Faiblesse : ce pion perd 1 PV
        const occ = getPieceAt(cell);
        if(occ){ occ.unit.hp = Math.max(0, occ.unit.hp - 1);
          log(`Faiblesse : ${occ.color} ${occ.unit.id} perd 1 PV.`);
          if(occ.unit.hp <= 0){ removeUnit(occ.color, occ.unit.id); }
          renderBoard();
        }
        return;
      }
      case 'reverse': {
        // Reverse : revenir sur la case précédente si possible, sinon -1 PV
        const info = state.lastLanding;
        if(info && info.to === cell){
          const u = findUnit(color, info.unitId);
          if(u){
            // Peut-on retourner sur from ?  (pas bloqué, pas occupé, pas fort)
            const from = info.from;
            if(from && !state.blocks.has(from) && !getPieceAt(from) && !isFortCell(from)){
              u.cell = from;
              log(`Reverse : retour en ${from}.`);
              renderBoard();
            } else {
              // Impossible : -1 PV
              u.hp = Math.max(0, u.hp - 1);
              log('Reverse : retour impossible → -1 PV.');
              if(u.hp <= 0){ removeUnit(color, u.id); }
              renderBoard();
            }
          }
        }
        return;
      }
      // ----- Blank -----
      case 'blank': {
        log('Tuile blanche : aucun effet.');
        return;
      }
    }
  }

  // ===== Tile commit helpers =====
  function commitTileHeal1(alg){
    const info = state.inProgress;
    if(!info || info.mode !== 'TILE_HEAL1') return;
    const color = info.color;
    // Heal fort if clicked on fort
    if(alg === FORT_BLUE || alg === FORT_RED){
      const fortColor = (alg === FORT_BLUE ? 'blue' : 'red');
      if(fortColor === color){
        state.pieces[fortColor].fortHP = Math.min(10, state.pieces[fortColor].fortHP + 1);
        log('Pansement : forteresse soignée (+1 PV).');
      }
    } else {
      const occ = getPieceAt(alg);
      if(occ && occ.color === color){
        // Ne soigner que les pions blessés (hp < 2). Si le pion est déjà à 2 PV, aucun effet.
if ((occ.unit.hp || 0) >= 2) {
  log('Pansement : uniquement sur pion blessé (1 PV).');
} else {
  occ.unit.hp = Math.min(2, (occ.unit.hp || 0) + 1);
  log(`Pansement : ${occ.color} ${occ.unit.id} +1 PV.`);
}
      }
    }
    state.inProgress = null;
    applyHighlights();
    renderBoard();
    renderTop();
  }

  function commitTileWheel(alg){
    const info = state.inProgress;
    if(!info || info.mode !== 'TILE_WHEEL') return;
    // Remove block if there is one, else place a block if possible
    if(state.blocks.has(alg)){
      state.blocks.delete(alg);
      log(`Molette : bloc retiré en ${alg}.`);
    } else {
      // Validate position for placing a block: cannot place on orange/spawn/fort and cannot exceed 6 blocks
      if(isFortCell(alg) || ORANGE.has(alg) || RED_SPAWN.has(alg) || BLUE_SPAWN.has(alg)){
        // invalid cell, ignore
      } else if(state.blocks.size >= 6){
        log('Molette : maximum de 6 blocs actifs atteint.');
      } else if(!getPieceAt(alg)){
        state.blocks.add(alg);
        log(`Molette : bloc placé en ${alg}.`);
      }
    }
    state.inProgress = null;
    applyHighlights();
    renderBoard();
    renderTop();
  }

  // ===== Card play =====
  function playCard(color, idx){
    // Ne rien faire si la partie est terminée
    if(state.gameOver) return;
    // Not your turn
    if(state.active!==color){ log('Ce n\'est pas votre tour.'); return; }
    // Only allow playing in phase 'actions'
    if(state.phase !== 'actions'){ log('Vous n\'êtes pas en phase d\'actions.'); return; }
    // Respecter la limite de cartes jouées par tour (3 + bonus éventuel)
    const limit = 3 + (state.flags.extraCard ? state.flags.extraCard : 0);
    if(state.played >= limit){ log('Limite de cartes jouées atteinte.'); return; }
    // Si un déplacement est en cours, le conclure ou l'annuler avant de jouer une autre carte
    if(state.inProgress){
      if(state.inProgress.mode==='MOVE'){
        const info = state.inProgress;
        // Aucun pas effectué → annuler la carte (pas de défausse et pas de révélation)
        if(info.remaining === info.initial){
          cancelMoveCard();
        } else {
          // Des pas ont été faits : commit puis révéler la tuile à l'endroit atteint
          commitMoveInProgress();
          triggerTileAtEndIfAny();
        }
      } else {
        commitMoveInProgress();
      }
    }
    const P=state.pieces[color]; const card=P.hand[idx];
    if(!card) return;
    switch(card.t){
      case 'MOVE': playMoveCard(color, idx, card.n); break;
      case 'MELEE_SWAP': playMeleeOrSwap(color, idx); break;
      case 'RANGE_TP': playRangeOrTP(color, idx); break;
      case 'HEAL_REINFORCE': playHealOrReinforce(color, idx); break;
      case 'BLOCK_UNBLOCK': playBlockOrUnblock(color, idx); break;
      default: log('Carte non reconnue.');
    }
  }

  // ===== MOVE =====
  function playMoveCard(color, idx, steps){
    if(!state.selected || state.selected.color!==color){ log('Sélectionnez un de vos pions pour jouer cette carte.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
    const P=state.pieces[color]; const cardObj=P.hand[idx]; const cardId=cardObj.id;
    // Démarrer un déplacement : stocker aussi le nombre de pas initial pour détecter si aucun pas n'a été effectué
    state.inProgress={mode:'MOVE', color, unitId:unit.id, cardId, remaining:steps, initial:steps};
    applyHighlights();
    renderHands(); // mettre à jour l'interface pour afficher le bouton Défausser
    log(`Carte Déplacement ${steps}: cliquez les cases vertes pour chaque pas.`);
  }
  function commitMoveInProgress(){
    if(!state.inProgress || state.inProgress.mode!=='MOVE') return;
    const {color, cardId}=state.inProgress;
    const P=state.pieces[color]; const idx=P.hand.findIndex(c=>c.id===cardId);
    if(idx>=0){ const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); }
    state.played++;
    state.inProgress=null;
    applyHighlights(); renderHands(); updateDeckUI();
  }

  // Annuler un déplacement en cours sans le défausser (aucun pas effectué)
  function cancelMoveCard(){
    if(!state.inProgress || state.inProgress.mode!=='MOVE') return;
    // remettre simplement l'état sans défausser la carte, ni augmenter le compteur de cartes jouées
    state.inProgress = null;
    applyHighlights();
    renderHands();
    // pas de changement dans la main ou la défausse
  }

  function commitBlockInProgress(cell){
    // Ajouter un bloc à l'emplacement spécifié et défausser la carte
    const {color, cardId} = state.inProgress;
    state.blocks.add(cell);
    log(`Bloc placé en ${cell}.`);
    const P = state.pieces[color];
    const idx = P.hand.findIndex(c => c.id === cardId);
    if(idx>=0){ const [card] = P.hand.splice(idx,1); if(card) P.discard.push(card); }
    state.played++;
    state.inProgress = null;
    applyHighlights(); renderHands(); updateDeckUI(); renderBoard();
  }

  // ===== MELEE / ECH =====
  function playMeleeOrSwap(color, idx){
    if(!state.selected || state.selected.color!==color){ log('Sélectionnez un de vos pions pour jouer cette carte.'); return; }
    const choice=prompt('Entrez "CAC" pour attaque corps-à-corps ou "ECH" pour échange:','CAC'); if(!choice) return;
    if(choice.toUpperCase()==='CAC'){ doMelee(color, idx); } else { doSwap(color, idx); }
  }
  function doMelee(color, idx){
    if(state.flags.disarmed){ log('Désarmé: pas d\'attaque.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
    const target=prompt('Cible adjacente (coordonnée) :',''); if(!target) return;
    const alg=target.toUpperCase();
    // allow targeting fort
    if(!valid.has(alg) && alg!==FORT_BLUE && alg!==FORT_RED){ log('Cible invalide.'); return; }
    if(!isAdjacent4(unit.cell, alg)){ log('Cible non adjacente.'); return; }
    // attack fort or unit
    if(alg===FORT_BLUE || alg===FORT_RED){
      const fortColor=(alg===FORT_BLUE?'blue':'red');
      if(fortColor===color){ log('Impossible d\'attaquer sa propre forteresse.'); return; }
      rollDamageFort(fortColor);
    } else {
      const occ=getPieceAt(alg);
      if(!occ || occ.color===color){ log('Pas d\'ennemi à cette case.'); return; }
      rollDamage(occ.unit, occ.color);
    }
    if(state.flags.pressure){ promptDiscard(color==='blue'?'red':'blue',1); state.flags.pressure=false; }
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }
  function doSwap(color, idx){
    if(state.flags.noMagic){ log('Anti-magie: Échange impossible.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
    const target=prompt('Cible pour échange (coordonnée):',''); if(!target) return;
    const alg=target.toUpperCase();
    if(!valid.has(alg) && alg!==FORT_BLUE && alg!==FORT_RED){ log('Cible invalide.'); return; }
    // cannot swap with fort
    if(alg===FORT_BLUE || alg===FORT_RED){ log('Impossible d\'échanger avec une forteresse.'); return; }
    const occ=getPieceAt(alg);
    if(!occ){ log('Aucun pion sur cette case.'); return; }
    if(!isLOS(unit.cell, occ.unit.cell)){ log('Pas de ligne de vue.'); return; }
    if(occ.color!==color){
      // cannot swap with enemy in their spawn zone
      if((occ.color==='red' && RED_SPAWN.has(occ.unit.cell)) || (occ.color==='blue' && BLUE_SPAWN.has(occ.unit.cell))){ log('Interdit: ennemi dans sa zone de départ.'); return; }
    }
    // Vérifier anti-magie pour le pion actif
    if(unit && unit.noMagic){ log('Anti-magie: Échange impossible pour ce pion.'); return; }
    // swap positions
    const tmp=unit.cell; unit.cell=occ.unit.cell; occ.unit.cell=tmp;
    // Enregistrer l'atterrissage du joueur actif
    state.lastLanding = { color, unitId: unit.id, from: tmp, to: unit.cell, kind:'SWAP' };
    // Révéler la tuile pour le joueur actif si applicable
    if(!state.tileRevealedThisTurn[color] && !state.blocks.has(unit.cell)){
      const t = state.tiles[unit.cell];
      if(t && !t.revealed){
        t.revealed = true;
        state.tileRevealedThisTurn[color] = true;
        log(`[Tuile] Révélée en ${unit.cell} → ${tileLabel(t)}.`);
        applyTileEffect(unit.cell, color, t);
        delete state.tiles[unit.cell];
        updateTilesUI();
      }
    }
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }

  // ===== RANGE / TP =====
  function playRangeOrTP(color, idx){
    if(!state.selected || state.selected.color!==color){ log('Sélectionnez un de vos pions.'); return; }
    const choice=prompt('Entrez "DIST" pour attaque à distance ou "TP" pour téléportation:','DIST'); if(!choice) return;
    if(choice.toUpperCase()==='DIST'){ doRanged(color, idx); } else { doTeleport(color, idx); }
  }
  function doRanged(color, idx){
    if(state.flags.disarmed){ log('Désarmé: pas d\'attaque.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
    const target=prompt('Cible (coordonnée, forteresse ou pion ennemi) :',''); if(!target) return;
    const alg=target.toUpperCase();
    if(alg!==FORT_BLUE && alg!==FORT_RED && !valid.has(alg)){ log('Cible invalide.'); return; }
    // cannot target adjacent cells
    if(isAdjacent4(unit.cell, alg)){ log('Cible adjacente: utilisez CAC.'); return; }
    const A=fromAlg(unit.cell);
    const B=fromAlg(alg===FORT_BLUE?FORT_BLUE: alg===FORT_RED?FORT_RED: alg);
    const dx=Math.abs(A.c-B.c), dy=Math.abs(A.r-B.r);
    const ortho=(dx===0||dy===0) && (dx+dy>=2 && dx+dy<=4);
    const diag=(dx===dy) && (dx>=1 && dx<=2);
    if(!(ortho||diag)){ log('Portée invalide (2-4 ortho ou 1-2 diag).'); return; }
    if(!isLOS(unit.cell, alg)){ log('Pas de ligne de vue.'); return; }
    // attack fort or unit
    if(alg===FORT_BLUE || alg===FORT_RED){
      const fortColor=(alg===FORT_BLUE?'blue':'red');
      if(fortColor===color){ log('Impossible de viser sa propre forteresse.'); return; }
      rollDamageFort(fortColor);
    } else {
      const occ=getPieceAt(alg);
      if(!occ || occ.color===color){ log('Pas d\'ennemi à cette case.'); return; }
      rollDamage(occ.unit, occ.color);
    }
    if(state.flags.pressure){ promptDiscard(color==='blue'?'red':'blue',1); state.flags.pressure=false; }
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }
  function doTeleport(color, idx){
    if(state.flags.noMagic){ log('Anti-magie: pas de téléportation.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
    const target=prompt('Destination (coordonnée) :',''); if(!target) return;
    const alg=target.toUpperCase();
    if(!valid.has(alg)){ log('Destination invalide.'); return; }
    if(getPieceAt(alg) || state.blocks.has(alg) || isFortCell(alg)){ log('Case occupée, bloquée ou forteresse.'); return; }
    if(!isLOS(unit.cell, alg)){ log('Pas de ligne de vue.'); return; }
    if(color==='blue' && RED_SPAWN.has(alg)){ log('Interdit: zone rouge.'); return; }
    if(color==='red'  && BLUE_SPAWN.has(alg)){ log('Interdit: zone bleue.'); return; }
    // Anti-magie par pion : interdit de téléporter si la tuile antimagic affecte ce pion
    if(unit.noMagic){ log('Anti-magie: ce pion ne peut pas se téléporter.'); return; }
    const from = unit.cell;
    unit.cell = alg;
    // Enregistrer l'atterrissage
    state.lastLanding = { color, unitId: unit.id, from, to: alg, kind:'TP' };
    // Révéler la tuile immédiatement pour le joueur actif si applicable
    if(!state.tileRevealedThisTurn[color] && !state.blocks.has(alg)){
      const t = state.tiles[alg];
      if(t && !t.revealed){
        t.revealed = true;
        state.tileRevealedThisTurn[color] = true;
        log(`[Tuile] Révélée en ${alg} → ${tileLabel(t)}.`);
        applyTileEffect(alg, color, t);
        delete state.tiles[alg];
        updateTilesUI();
      }
    }
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }

  // ===== HEAL / REINFORCE =====
  function playHealOrReinforce(color, idx){
    const choice = prompt('"SOIN" pour +2 PV forteresse (max 10) ou "RENF" pour renfort:', 'SOIN');
    if(!choice) return;
    if(choice.toUpperCase() === 'SOIN'){
      // soin: augmenter PV forteresse et défausser la carte immédiatement
      const P = state.pieces[color];
      P.fortHP = Math.min(10, P.fortHP + 2);
      log('Forteresse '+color+' soignée (+2).');
      // retirer la carte de la main
      const P2 = state.pieces[color];
      const card = P2.hand[idx];
      if(card){
        P2.hand.splice(idx,1);
        P2.discard.push(card);
      }
      state.played++;
      renderHands();
      updateDeckUI();
      renderBoard();
    } else {
      // renfort: entrer en mode de placement interactif
      const P = state.pieces[color];
      const reserve = P.pieces.find(u => u.cell === null);
      if(!reserve){
        log('Pas de pion en réserve.');
        return;
      }
      const onBoard = P.pieces.filter(u => u.cell).length;
      if(onBoard >= 7){
        log('Trop de pions sur le plateau.');
        return;
      }
      // garder la carte et noter son id pour défausse après placement
      const cardObj = P.hand[idx];
      state.inProgress = {mode:'RENF', color, cardId: cardObj.id};
      applyHighlights();
      log((color==='blue'?'🔵':'🔴')+' Renfort : cliquez une case libre de votre zone pour poser le pion.');
      // on ne retire pas encore la carte : ce sera fait lors du placement effectif
    }
  }

  // ===== BLOCK / UNBLOCK =====
  function playBlockOrUnblock(color, idx){
    const choice=prompt('"BLOC" pour placer un bloc, "DEBLOC" pour retirer:','BLOC'); if(!choice) return;
    if(choice.toUpperCase()==='BLOC'){
      if(state.blocks.size>=6){ log('Maximum de blocs actifs.'); return; }
      if(!state.selected || state.selected.color!==color){ log('Sélectionnez un pion pour placer un bloc.'); return; }
      const unit=findUnit(color,state.selected.id);
      if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
      // déterminer les cases adjacentes valides pour placer un bloc
      const candidates = neighbors4(unit.cell).filter(c=> !state.blocks.has(c) && !getPieceAt(c) && !RED_SPAWN.has(c) && !BLUE_SPAWN.has(c) && !ORANGE.has(c) && !isFortCell(c));
      if(candidates.length===0){ log('Aucune case valide pour placer un bloc.'); return; }
      // mettre en surbrillance ces cases et passer en mode BLOCK
      const P=state.pieces[color]; const cardObj=P.hand[idx];
      state.inProgress={mode:'BLOCK', color, unitId:unit.id, cardId:cardObj.id, candidates};
      applyHighlights();
      log('Sélectionnez une case jaune pour placer votre bloc.');
      return;
    } else {
      if(!state.selected || state.selected.color!==color){ log('Sélectionnez un pion pour retirer un bloc.'); return; }
      const unit=findUnit(color,state.selected.id);
      if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
      const cand=neighbors4(unit.cell).find(c=>state.blocks.has(c));
      if(!cand){ log('Aucun bloc adjacent à retirer.'); return; }
      state.blocks.delete(cand);
      log(`Bloc retiré de ${cand}.`);
      const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
      renderHands(); updateDeckUI(); renderBoard();
      return;
    }
  }

  // ===== NEW: actions sans prompt =====
  // Attaque de mêlée (CAC)
  function playMelee(color, idx){
    if(state.flags.disarmed){ log('Désarmé: pas d\'attaque.'); return; }
    // Sélection et validité
    if(!state.selected || state.selected.color !== color){ log('Sélectionnez un de vos pions pour attaquer.'); return; }
    const unit = findUnit(color, state.selected.id);
    if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
    // Déterminer les cibles adjacentes (ennemis ou fort adverse)
    const neigh = neighbors4(unit.cell);
    const candidates = [];
    neigh.forEach(coord => {
      if(coord === FORT_BLUE || coord === FORT_RED){
        const fortColor = (coord === FORT_BLUE ? 'blue' : 'red');
        if(fortColor !== color){
          candidates.push(coord);
        }
      } else if(valid.has(coord)){
        const occ = getPieceAt(coord);
        if(occ && occ.color !== color){
          candidates.push(coord);
        }
      }
    });
    if(candidates.length === 0){ log('Aucune cible adjacente.'); return; }
    const P = state.pieces[color];
    const cardObj = P.hand[idx];
    state.inProgress = {mode:'MELEE', color, unitId: unit.id, cardId: cardObj.id, candidates};
    applyHighlights();
    log('Attaque CAC : choisissez une cible.');
  }

  // Validation de l'attaque de mêlée lorsque la case est cliquée
  function commitMelee(alg){
    const info = state.inProgress;
    if(!info || info.mode !== 'MELEE') return;
    const color = info.color;
    const unit = findUnit(color, info.unitId);
    if(!unit || !unit.cell){ state.inProgress=null; applyHighlights(); return; }
    // Appliquer dégâts
    if(alg === FORT_BLUE || alg === FORT_RED){
      const fortColor = (alg === FORT_BLUE ? 'blue' : 'red');
      if(fortColor !== color){ rollDamageFort(fortColor); }
    } else {
      const occ = getPieceAt(alg);
      if(occ && occ.color !== color){ rollDamage(occ.unit, occ.color); }
    }
    if(state.flags.pressure){
      const other = (color === 'blue' ? 'red' : 'blue');
      promptDiscard(other, 1);
      state.flags.pressure = false;
    }
    // Défausser la carte
    const P = state.pieces[color];
    const idx = P.hand.findIndex(c => c.id === info.cardId);
    if(idx >= 0){ const card = P.hand.splice(idx,1)[0]; if(card) P.discard.push(card); }
    state.played++;
    state.inProgress = null;
    state.selected = null;
    applyHighlights();
    renderHands(); updateDeckUI(); renderBoard();
    checkGameOver();
  }

  // Échange
  function playSwap(color, idx){
    // Vérifier anti-magie global et par pion
    if(state.flags.noMagic){ log('Anti-magie: Échange impossible.'); return; }
    if(state.selected){
      const u = findUnit(state.selected.color, state.selected.id);
      if(u && u.noMagic){ log('Anti-magie: ce pion ne peut pas échanger.'); return; }
    }
    if(!state.selected || state.selected.color !== color){ log('Sélectionnez un de vos pions pour échanger.'); return; }
    const unit = findUnit(color, state.selected.id);
    if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
    // Chercher tous les pions (alliés ou ennemis) en ligne de vue
    const candidates = [];
    ['blue','red'].forEach(clr => {
      state.pieces[clr].pieces.forEach(p => {
        if(p.cell){
          if(clr === color && p.id === unit.id) return; // pas soi-même
          // ligne de vue
          if(isLOS(unit.cell, p.cell)){
            // si ennemi, vérifier qu'il n'est pas dans sa zone de départ
            if(clr !== color){
              if((clr === 'red' && RED_SPAWN.has(p.cell)) || (clr === 'blue' && BLUE_SPAWN.has(p.cell))) return;
            }
            candidates.push(p.cell);
          }
        }
      });
    });
    if(candidates.length === 0){ log('Aucun pion en ligne de vue pour échanger.'); return; }
    const P = state.pieces[color];
    const cardObj = P.hand[idx];
    state.inProgress = {mode:'SWAP', color, unitId: unit.id, cardId: cardObj.id, candidates};
    applyHighlights();
    log('Échange : choisissez un pion en vue.');
  }

  function commitSwap(alg){
    const info = state.inProgress;
    if(!info || info.mode !== 'SWAP') return;
    const color = info.color;
    const unit = findUnit(color, info.unitId);
    if(!unit || !unit.cell){ state.inProgress = null; applyHighlights(); return; }
    if(alg === FORT_BLUE || alg === FORT_RED){ log('Impossible d\'échanger avec une forteresse.'); return; }
    const occ = getPieceAt(alg);
    if(!occ){ log('Aucun pion sur cette case.'); state.inProgress = null; applyHighlights(); return; }
    // Vérifier de nouveau la zone de départ ennemie
    if(occ.color !== color){
      if((occ.color === 'red' && RED_SPAWN.has(occ.unit.cell)) || (occ.color === 'blue' && BLUE_SPAWN.has(occ.unit.cell))){
        log('Interdit d\'échanger avec un ennemi dans sa zone de départ.');
        state.inProgress = null;
        applyHighlights();
        return;
      }
    }
    // Vérifier anti-magie pour le pion actif
    if(unit.unit && unit.unit.noMagic){
      log('Anti-magie : ce pion ne peut pas échanger.');
      state.inProgress = null;
      applyHighlights();
      return;
    }
    // Échanger les positions
    const tmp = unit.cell;
    unit.cell = occ.unit.cell;
    occ.unit.cell = tmp;
    // Enregistrer l'atterrissage du joueur actif
    state.lastLanding = { color, unitId: unit.id, from: tmp, to: unit.cell, kind:'SWAP' };
    // Révélation pour le joueur actif seulement
    if(!state.tileRevealedThisTurn[color] && !state.blocks.has(unit.cell)){
      const t = state.tiles[unit.cell];
      if(t && !t.revealed){
        t.revealed = true;
        state.tileRevealedThisTurn[color] = true;
        log(`[Tuile] Révélée en ${unit.cell} → ${tileLabel(t)}.`);
        applyTileEffect(unit.cell, color, t);
        delete state.tiles[unit.cell];
        updateTilesUI();
      }
    }
    // Défausser la carte
    const P = state.pieces[color];
    const idx = P.hand.findIndex(c => c.id === info.cardId);
    if(idx >= 0){ const card = P.hand.splice(idx,1)[0]; if(card) P.discard.push(card); }
    state.played++;
    state.inProgress = null;
    state.selected = null;
    applyHighlights();
    renderHands(); updateDeckUI(); renderBoard();
  }

  // Attaque à distance
  function playRangeAttack(color, idx){
    if(state.flags.disarmed){ log('Désarmé: pas d\'attaque.'); return; }
    if(!state.selected || state.selected.color !== color){ log('Sélectionnez un de vos pions.'); return; }
    const unit = findUnit(color, state.selected.id);
    if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
    const candidates = [];
    // Fort adverse
    const enemyFort = (color === 'blue' ? FORT_RED : FORT_BLUE);
    if(!isAdjacent4(unit.cell, enemyFort) && isLOS(unit.cell, enemyFort)){
      const A = fromAlg(unit.cell);
      const B = fromAlg(enemyFort);
      const dx = Math.abs(A.c - B.c), dy = Math.abs(A.r - B.r);
      const ortho = (dx === 0 || dy === 0) && (dx + dy >= 2 && dx + dy <= 4);
      const diag = (dx === dy) && (dx >= 1 && dx <= 2);
      if(ortho || diag) candidates.push(enemyFort);
    }
    // Pions ennemis
    const enemyColor = (color === 'blue' ? 'red' : 'blue');
    state.pieces[enemyColor].pieces.forEach(p => {
      if(p.cell){
        if(isAdjacent4(unit.cell, p.cell)) return; // adjacent non valide pour distance
        if(!isLOS(unit.cell, p.cell)) return;
        const A = fromAlg(unit.cell);
        const B = fromAlg(p.cell);
        const dx = Math.abs(A.c - B.c), dy = Math.abs(A.r - B.r);
        const ortho = (dx === 0 || dy === 0) && (dx + dy >= 2 && dx + dy <= 4);
        const diag = (dx === dy) && (dx >= 1 && dx <= 2);
        if(ortho || diag) candidates.push(p.cell);
      }
    });
    if(candidates.length === 0){ log('Aucune cible valide à distance.'); return; }
    const P = state.pieces[color];
    const cardObj = P.hand[idx];
    state.inProgress = {mode:'RANGE', color, unitId: unit.id, cardId: cardObj.id, candidates};
    applyHighlights();
    log('Attaque à distance : choisissez une cible.');
  }

  function commitRangeAttack(alg){
    const info = state.inProgress;
    if(!info || info.mode !== 'RANGE') return;
    const color = info.color;
    const unit = findUnit(color, info.unitId);
    if(!unit || !unit.cell){ state.inProgress = null; applyHighlights(); return; }
    // Appliquer dégâts
    if(alg === FORT_BLUE || alg === FORT_RED){
      const fortColor = (alg === FORT_BLUE ? 'blue' : 'red');
      if(fortColor !== color){ rollDamageFort(fortColor); }
    } else {
      const occ = getPieceAt(alg);
      if(occ && occ.color !== color){ rollDamage(occ.unit, occ.color); }
    }
    if(state.flags.pressure){
      const other = (color === 'blue' ? 'red' : 'blue');
      promptDiscard(other, 1);
      state.flags.pressure = false;
    }
    // Défausser la carte uniquement si cette attaque provient d'une carte (pas d'une tuile)
    const P = state.pieces[color];
    if(info.cardId){
      const idx = P.hand.findIndex(c => c.id === info.cardId);
      if(idx >= 0){ const card = P.hand.splice(idx,1)[0]; if(card) P.discard.push(card); }
      state.played++;
    }
    state.inProgress = null;
    state.selected = null;
    applyHighlights();
    renderHands(); updateDeckUI(); renderBoard();
    checkGameOver();
  }

  // Téléportation
  function playTeleport(color, idx){
    if(state.flags.noMagic){ log('Anti-magie: pas de téléportation.'); return; }
    // Vérifier anti-magie par pion
    if(state.selected){
      const u = findUnit(state.selected.color, state.selected.id);
      if(u && u.noMagic){ log('Anti-magie: ce pion ne peut pas se téléporter.'); return; }
    }
    if(!state.selected || state.selected.color !== color){ log('Sélectionnez un de vos pions pour téléporter.'); return; }
    const unit = findUnit(color, state.selected.id);
    if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
    const candidates = [];
    valid.forEach(coord => {
      if(getPieceAt(coord) || state.blocks.has(coord) || isFortCell(coord)) return;
      // pas dans zone de spawn adverse
      if(color === 'blue' && RED_SPAWN.has(coord)) return;
      if(color === 'red' && BLUE_SPAWN.has(coord)) return;
      if(!isLOS(unit.cell, coord)) return;
      if(coord === unit.cell) return;
      candidates.push(coord);
    });
    if(candidates.length === 0){ log('Aucune destination valide pour téléportation.'); return; }
    const P = state.pieces[color];
    const cardObj = P.hand[idx];
    state.inProgress = {mode:'TP', color, unitId: unit.id, cardId: cardObj.id, candidates};
    applyHighlights();
    log('Téléportation : choisissez une case libre en vue.');
  }

  function commitTeleport(alg){
    const info = state.inProgress;
    if(!info || info.mode !== 'TP') return;
    const color = info.color;
    const unit = findUnit(color, info.unitId);
    if(!unit || !unit.cell){ state.inProgress = null; applyHighlights(); return; }
    if(getPieceAt(alg) || state.blocks.has(alg) || isFortCell(alg)){
      state.inProgress = null;
      applyHighlights();
      return;
    }
    if(color === 'blue' && RED_SPAWN.has(alg)){ state.inProgress=null; applyHighlights(); return; }
    if(color === 'red' && BLUE_SPAWN.has(alg)){ state.inProgress=null; applyHighlights(); return; }
    if(!isLOS(unit.cell, alg)){ state.inProgress=null; applyHighlights(); return; }
    // Teleport only if the unit is allowed (anti-magie handled on unit)
    if(unit.unit && unit.unit.noMagic){
      log('Anti-magie : ce pion ne peut pas se téléporter.');
      state.inProgress = null;
      applyHighlights();
      return;
    }
    const from = unit.cell;
    unit.cell = alg;
    // Enregistrer l'atterrissage
    state.lastLanding = { color, unitId: unit.id, from, to: alg, kind:'TP' };
    // Révélation immédiate d'une tuile si autorisé et non bloqué
    if(!state.tileRevealedThisTurn[color] && !state.blocks.has(alg)){
      const t = state.tiles[alg];
      if(t && !t.revealed){
        t.revealed = true;
        state.tileRevealedThisTurn[color] = true;
        log(`[Tuile] Révélée en ${alg} → ${tileLabel(t)}.`);
        applyTileEffect(alg, color, t);
        delete state.tiles[alg];
        updateTilesUI();
      }
    }
    const P = state.pieces[color];
    const idx = P.hand.findIndex(c => c.id === info.cardId);
    if(idx >= 0){ const card = P.hand.splice(idx,1)[0]; if(card) P.discard.push(card); }
    state.played++;
    state.inProgress = null;
    state.selected = null;
    applyHighlights();
    renderHands(); updateDeckUI(); renderBoard();
  }

  // Soin
  function playHeal(color, idx){
    const P = state.pieces[color];
    // Appliquer +2 PV (max 10)
    P.fortHP = Math.min(10, P.fortHP + 2);
    log('Forteresse ' + (color === 'blue' ? 'bleue' : 'rouge') + ' soignée (+2).');
    // Retirer la carte de la main
    const card = P.hand[idx];
    if(card){ P.hand.splice(idx,1); P.discard.push(card); }
    state.played++;
    state.selected = null;
    applyHighlights();
    renderHands(); updateDeckUI(); renderBoard();
  }

  // Renfort
  function playReinforce(color, idx){
    const P = state.pieces[color];
    const reserve = P.pieces.find(u => u.cell === null);
    if(!reserve){ log('Pas de pion en réserve.'); return; }
    const onBoard = P.pieces.filter(u => u.cell).length;
    if(onBoard >= 7){ log('Trop de pions sur le plateau.'); return; }
    const cardObj = P.hand[idx];
    // On stocke l'ID de la carte pour la défausser après placement
    state.inProgress = {mode:'RENF', color, cardId: cardObj.id};
    applyHighlights();
    log((color === 'blue' ? '🔵' : '🔴') + ' Renfort : cliquez une case libre de votre zone pour poser le pion.');
  }

  // Blocage
  function playBlock(color, idx){
    if(state.blocks.size >= 6){ log('Maximum de blocs actifs.'); return; }
    if(!state.selected || state.selected.color !== color){ log('Sélectionnez un pion pour placer un bloc.'); return; }
    const unit = findUnit(color, state.selected.id);
    if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
    const candidates = neighbors4(unit.cell).filter(coord => {
      return !state.blocks.has(coord) && !getPieceAt(coord) && !RED_SPAWN.has(coord) && !BLUE_SPAWN.has(coord) && !ORANGE.has(coord) && !isFortCell(coord);
    });
    if(candidates.length === 0){ log('Aucune case valide pour placer un bloc.'); return; }
    const P = state.pieces[color]; const cardObj = P.hand[idx];
    state.inProgress = {mode:'BLOCK', color, unitId: unit.id, cardId: cardObj.id, candidates};
    applyHighlights();
    log('Sélectionnez une case jaune pour placer votre bloc.');
  }

  // Déblocage
  function playUnblock(color, idx){
    if(!state.selected || state.selected.color !== color){ log('Sélectionnez un pion pour retirer un bloc.'); return; }
    const unit = findUnit(color, state.selected.id);
    if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
    const cand = neighbors4(unit.cell).find(c => state.blocks.has(c));
    if(!cand){ log('Aucun bloc adjacent à retirer.'); return; }
    state.blocks.delete(cand);
    log(`Bloc retiré de ${cand}.`);
    const P = state.pieces[color];
    const cardObj = P.hand[idx];
    if(cardObj){
      const pos = P.hand.findIndex(c => c.id === cardObj.id);
      if(pos >= 0){ const removed = P.hand.splice(pos,1)[0]; if(removed) P.discard.push(removed); }
    }
    state.played++;
    state.selected = null;
    applyHighlights();
    renderHands(); updateDeckUI(); renderBoard();
  }

  // ===== Combat & dégâts =====
  function rollDamage(targetUnit, targetColor){
    const roll=((Math.random()*6)|0)+1; let dmg=(roll===1||roll===6)?2:1;
    if(state.flags.weakenCrit && (roll===1||roll===6)) dmg=1;
    targetUnit.hp-=dmg;
    log(`Jet ${roll} → ${dmg} dégât(s) sur ${targetColor} ${targetUnit.id}.`);
    if(targetUnit.hp<=0){ removeUnit(targetColor, targetUnit.id); }
    state.flags.weakenCrit=false;
    renderBoard();
  }
  function rollDamageFort(color){
    const roll=((Math.random()*6)|0)+1; let dmg=(roll===1||roll===6)?2:1;
    if(state.flags.weakenCrit && (roll===1||roll===6)) dmg=1;
    state.pieces[color].fortHP=Math.max(0, state.pieces[color].fortHP-dmg);
    log(`Jet ${roll} → ${dmg} dégât(s) sur forteresse ${color}.`);
    state.flags.weakenCrit=false;
    renderBoard();
    checkGameOver();
  }
  function removeUnit(color,id){ const P=state.pieces[color]; const idx=P.pieces.findIndex(u=>u.id===id); if(idx>-1){ P.pieces[idx].cell=null; P.pieces[idx].hp=2; log(`${color} ${id} retiré du plateau.`); } }
  function promptDiscard(color,n){
  // Set a forced discard state so the player can CHOOSE which cards to discard.
  // This disables all play buttons for that side until the required discards are done.
  if(!state.forcedDiscard){
    state.forcedDiscard = { color, remaining: n };
  } else {
    // accumulate if called again
    if(state.forcedDiscard.color === color){
      state.forcedDiscard.remaining += n;
    } else {
      // If both colors are forced in theory, serialize: handle current then later.
      // For simplicity, queue on the same key.
      state.forcedDiscard = { color, remaining: n };
    }
  }
  log(`Défausse obligatoire (${color}) : choisissez ${state.forcedDiscard.remaining} carte(s) à défausser.`);
  renderHands();
}

  // ===== Zone orange damage =====
  function applyZoneDamage(){
    // Compute counts for both players
    const blueCount = state.pieces.blue.pieces.filter(u=>u.cell && ORANGE.has(u.cell)).length;
    const redCount  = state.pieces.red.pieces.filter(u=>u.cell && ORANGE.has(u.cell)).length;
    // Damage to red fort if blue dominates
    if(blueCount >= 3){
      const dmg=2;
      state.pieces.red.fortHP = Math.max(0, state.pieces.red.fortHP - dmg);
      log(`Zone orange : forteresse rouge -${dmg} PV.`);
    } else if(blueCount >= 2 && redCount <= 1){
      const dmg=1;
      state.pieces.red.fortHP = Math.max(0, state.pieces.red.fortHP - dmg);
      log(`Zone orange : forteresse rouge -${dmg} PV.`);
    }
    // Damage to blue fort if red dominates
    if(redCount >= 3){
      const dmg=2;
      state.pieces.blue.fortHP = Math.max(0, state.pieces.blue.fortHP - dmg);
      log(`Zone orange : forteresse bleue -${dmg} PV.`);
    } else if(redCount >= 2 && blueCount <= 1){
      const dmg=1;
      state.pieces.blue.fortHP = Math.max(0, state.pieces.blue.fortHP - dmg);
      log(`Zone orange : forteresse bleue -${dmg} PV.`);
    }
    // Ensure board re-renders and check game over
    renderBoard();
    checkGameOver();
  }

  // ===== Click handling =====
  function onCellClick(alg, cellEl){
    // Setup phase: simultaneous placement and rearrangement
    if(!state.setup.done){
      const isBlueSpawn = BLUE_SPAWN.has(alg);
      const isRedSpawn  = RED_SPAWN.has(alg);
      if(isBlueSpawn || isRedSpawn){
        const color = isBlueSpawn ? 'blue' : 'red';
        const side = state.setup[color];
        const occ = getPieceAt(alg);
        // If clicking own piece: select for relocation
        if(occ && occ.color === color){
          side.selected = alg;
          applyHighlights();
          return;
        }
        // If clicking empty spawn cell
        if(!occ){
          // If has a selected own piece in spawn: move it here
          if(side.selected && (BLUE_SPAWN.has(side.selected) || RED_SPAWN.has(side.selected))){
            const who = state.pieces[color].pieces.find(u=>u.cell===side.selected);
            if(who){
              who.cell = alg;
              side.selected = null;
              renderBoard(); updateReadyButtons();
              return;
            }
          }
          // else place a new piece if less than 5 on board
          const onBoard = state.pieces[color].pieces.filter(u=>u.cell).length;
          if(onBoard < 5){
            const reserve = state.pieces[color].pieces.find(u=>u.cell===null);
            if(reserve){
              reserve.cell = alg;
              renderBoard(); updateReadyButtons();
            }
          }
          return;
        }
      }
      return;
    }

    // NEW: do nothing if game is over
    if(state.gameOver) return;

    // Setup: place pions at start
    if(!state.setup.done){
      const color = state.setup.mode;
      const spawn = color === 'blue' ? BLUE_SPAWN : RED_SPAWN;
      if(spawn.has(alg) && spawnCellFree(color, alg)){
        const P = state.pieces[color];
        const idx = P.pieces.findIndex(u => !u.cell);
        if(idx >= 0){
          P.pieces[idx].cell = alg;
          state.setup.placed++;
          log(`${color==='blue'?'🔵':'🔴'} place ${P.pieces[idx].id} en ${alg} (${state.setup.placed}/5).`);
          if(state.setup.placed >= 5){
            if(color === 'blue'){
              state.setup = {mode:'red', placed:0, done:false};
              log('Placement initial : 🔴 place 5 pions dans sa zone.');
            } else {
              state.setup = {mode:'', placed:0, done:true};
              log('Placement initial terminé. Cliquez « Déterminer le 1er joueur ».');
            }
          }
          renderBoard();
          renderHands();
          renderTop();
        }
      }
      return;
    }

    // Renfort placement
    if(state.inProgress && state.inProgress.mode === 'RENF'){
      const color = state.inProgress.color;
      const spawn = color === 'blue' ? BLUE_SPAWN : RED_SPAWN;
      if(spawn.has(alg) && spawnCellFree(color, alg)){
        const P = state.pieces[color];
        const reserve = P.pieces.find(u => u.cell === null);
        if(!reserve){
          log('Pas de pion en réserve.');
        } else {
          const onBoard = P.pieces.filter(u => u.cell).length;
          if(onBoard >= 7){
            log('Maximum 7 pions sur le plateau.');
          } else {
            reserve.cell = alg;
            log(`Renfort: ${reserve.id} placé en ${alg}.`);
            const idxCard = P.hand.findIndex(c => c.id === state.inProgress.cardId);
            if(idxCard >= 0){
              const card = P.hand.splice(idxCard, 1)[0];
              if(card) P.discard.push(card);
            }
            state.played++;
            state.inProgress = null;
            renderBoard();
            renderHands();
            updateDeckUI();
          }
        }
      }
      return;
    }

    // Block placement
    if(state.inProgress && state.inProgress.mode === 'BLOCK'){
      if(cellEl.classList.contains('target-ok')){
        // Valid target: place the block and consume the card
        commitBlockInProgress(alg);
      } else {
        // Click outside a valid block target cancels the block placement
        state.inProgress = null;
        applyHighlights();
        renderHands();
        renderTop();
      }
      return;
    }

    // Modes de combat/ciblage
    if(state.inProgress){
      const mode = state.inProgress.mode;
      // For each targeted mode, commit if the clicked cell is valid; otherwise cancel the mode.
      if(mode === 'MELEE'){
        if(cellEl.classList.contains('target-ok')){
          commitMelee(alg);
        } else {
          state.inProgress = null;
          applyHighlights();
          renderHands();
          renderTop();
        }
        return;
      }
      if(mode === 'SWAP'){
        if(cellEl.classList.contains('target-ok')){
          commitSwap(alg);
        } else {
          state.inProgress = null;
          applyHighlights();
          renderHands();
          renderTop();
        }
        return;
      }
      if(mode === 'RANGE'){
        if(cellEl.classList.contains('target-ok')){
          commitRangeAttack(alg);
        } else {
          state.inProgress = null;
          applyHighlights();
          renderHands();
          renderTop();
        }
        return;
      }
      if(mode === 'TP'){
        if(cellEl.classList.contains('target-ok')){
          commitTeleport(alg);
        } else {
          state.inProgress = null;
          applyHighlights();
          renderHands();
          renderTop();
        }
        return;
      }
      if(mode === 'TILE_HEAL1'){
        if(cellEl.classList.contains('target-ok')){
          commitTileHeal1(alg);
        } else {
          state.inProgress = null;
          applyHighlights();
          renderHands();
          renderTop();
        }
        return;
      }
      if(mode === 'TILE_WHEEL'){
        if(cellEl.classList.contains('target-ok')){
          commitTileWheel(alg);
        } else {
          state.inProgress = null;
          applyHighlights();
          renderHands();
          renderTop();
        }
        return;
      }
    }

    // Move card mode
    if(state.inProgress && state.inProgress.mode === 'MOVE'){
      const info = state.inProgress;
      const unit = findUnit(info.color, info.unitId);
      if(!unit || !unit.cell) return;
      if(!cellEl.classList.contains('move-ok')){
        if(info.remaining === info.initial){
          cancelMoveCard();
        }
        return;
      }
      const from = unit.cell;
      unit.cell = alg;
      if(state.selected && state.selected.color === info.color && state.selected.id === unit.id){
        state.selected.cell = alg;
      }
      // Enregistrer le dernier atterrissage mais ne pas révéler immédiatement
      state.lastLanding = { color: info.color, unitId: info.unitId, from, to: alg, kind:'MOVE' };
      info.remaining--;
      log(`Déplacement carte: ${from} → ${alg} (reste ${info.remaining}).`);
      if(info.remaining <= 0){
        // Fin du déplacement de la carte : défausser la carte et révéler la tuile si applicable
        commitMoveInProgress();
        triggerTileAtEndIfAny();
      }
      renderBoard();
      return;
    }

    // Normal selection
    const occ = getPieceAt(alg);
    if(occ && occ.color === state.active){
      state.selected = {color: occ.color, id: occ.unit.id, cell: occ.unit.cell};
      applyHighlights();
      return;
    }

    // Free move
    if(state.selected && state.freeMoveRemaining > 0){
      const unit = findUnit(state.selected.color, state.selected.id);
      if(unit && canStep(unit.cell, alg)){
        const from = unit.cell;
        unit.cell = alg;
        state.selected.cell = alg;
        state.freeMoveRemaining--;
        // Enregistrer ce pas comme dernier atterrissage du tour
        state.lastLanding = { color: state.active, unitId: unit.id, from, to: alg, kind:'FREE' };
        // Déclencher la révélation lorsque le déplacement gratuit est terminé
        if(state.freeMoveRemaining === 0){
          triggerTileAtEndIfAny();
        }
        log(`Pas gratuit: ${unit.id} → ${alg}.`);
        renderBoard();
        return;
      }
    }
  }

  // ===== End turn =====
  function endTurn(){
    // If we are in the actions phase, switch to preparation: allow discarding up to 2 cards
    if(state.phase === 'actions'){
      // Lorsque l'on passe en phase de préparation et qu'un déplacement est en cours,
      // il faut commit le déplacement (si des pas ont été utilisés) et révéler la tuile
      if(state.inProgress && state.inProgress.mode === 'MOVE'){
        const info = state.inProgress;
        if(info.remaining === info.initial){
          // Aucun pas : annuler la carte
          cancelMoveCard();
        } else {
          // Des pas ont été utilisés : commit puis révélation de la tuile
          commitMoveInProgress();
          triggerTileAtEndIfAny();
        }
      }
      // Switch to preparation phase
      state.phase = 'préparation';
      state.discardLeft = 2;
      // Réinitialiser l'état de sélection et de déplacement gratuit
      state.inProgress = null;
      state.selected = null;
      state.freeMoveRemaining = 0;
      renderTop(); renderBoard(); renderHands();
      log('Phase de préparation : vous pouvez défausser jusqu\'à 2 cartes.');
      return;
    }
    // Otherwise we are in préparation: finalize the turn
    // Apply zone orange damage for both players (dominant side damages the other)
    applyZoneDamage();
    // Pioche pour le joueur courant avant de changer d'actif
    const me = state.active;
    if(state.flags.drawTo4){ drawTo(me,4); state.flags.drawTo4=false; } else { drawTo(me,5); }
    // Reset per-turn state
    state.played = 0;
    // Effets temporaires : réinitialiser les drapeaux à la fin du tour
    // Certaines tuiles définissent drawTo4, weakenCrit, disarmed, pressure, extraCard
    // Nous remettons toutes ces valeurs à zéro ici avant le prochain tour
    state.flags.drawTo4 = false;
    state.flags.weakenCrit = false;
    state.flags.disarmed = false;
    state.flags.pressure = false;
    state.flags.extraCard = 0;
    // Libérer la magie bloquée sur les pions (anti-magie) et réinitialiser les flags par pion
    ['blue','red'].forEach(clr => {
      state.pieces[clr].pieces.forEach(u => {
        if(u) u.noMagic = false;
      });
    });
    // Réinitialiser les autres flags
    state.flags.noMagic = false;
    state.freeMoveRemaining = 1;
    state.inProgress = null;
    state.selected = null;
    state.discardLeft = 0;
    // Reset tile reveal quota and landing context for the outgoing player
    state.tileRevealedThisTurn[state.active] = false;
    state.lastLanding = null;
    // Advance to next active player, handling first turn mode
    if(state.firstTurnMode){
      if(state.active === state.firstOrder){
        state.immunity.p1 = false;
        state.active = (state.firstOrder === 'blue' ? 'red' : 'blue');
      } else {
        state.immunity.p2 = false;
        state.firstTurnMode = false;
        state.turn = 1;
        state.active = state.firstOrder;
      }
    } else {
      state.active = (state.active === 'blue' ? 'red' : 'blue');
      state.turn++;
    }
    state.phase = 'actions';
    renderTop(); renderBoard(); renderHands();
  }

  // ===== Fin de partie =====
  function checkGameOver(){
    if(state.pieces.blue.fortHP<=0 || state.pieces.red.fortHP<=0){
      const winner = state.pieces.blue.fortHP<=0 ? 'rouge' : 'bleu';
      gameOver(winner);
    }
  }
  function gameOver(winner){
    if(state.gameOver) return;
    state.gameOver = true;
    log('Partie terminée ! Le joueur '+winner+' a gagné.');
    // Désactiver toutes les actions
    document.querySelectorAll('.playbtn').forEach(btn=> btn.disabled=true);
    document.getElementById('btnEndTurn').disabled = true;
    document.getElementById('btnPlaceTiles').disabled = true;
    // Optionnel : offrir de réinitialiser
  }

  // ===== UI top =====
  function renderTop(){
    $('#turnLabel').textContent=state.turn;
    $('#activePlayer').textContent=(state.active==='blue'?'🔵 Bleu':'🔴 Rouge');
    $('#phase').textContent=state.phase;
    $('#blueHP').textContent=state.pieces.blue.fortHP;
    $('#redHP').textContent=state.pieces.red.fortHP;
    $('#im1').textContent=state.immunity.p1?'✔':'—';
    $('#im2').textContent=state.immunity.p2?'✔':'—';
    $('#blocksActive').textContent=state.blocks.size;
    updateTilesUI();

    // Mettre à jour l'affichage du nombre de cartes jouées
    const limit = 3 + (state.flags.extraCard ? 1 : 0);
    const played = state.played;
    const cardsEl = document.getElementById('cardsPlayed');
    if(cardsEl) cardsEl.textContent = `${played}/${limit}`;

    // Changer l'étiquette du bouton de fin de tour en fonction de la phase
    const endBtn = document.getElementById('btnEndTurn');
    if(endBtn){
      // Désactiver pendant la phase de placement initial
      if(!state.setup.done){
        endBtn.disabled = true;
        endBtn.textContent = 'Placement...';
      } else {
        if(state.phase === 'actions') endBtn.textContent = 'Fin de tour'; else if(state.phase === 'préparation') endBtn.textContent = 'Terminer préparation';
        // Désactiver le bouton si la partie est finie
        endBtn.disabled = !!state.gameOver;
      }
    }
  }

  // ===== Buttons =====
  $('#btnReset').addEventListener('click', initGame);
  $('#btnPlaceTiles').addEventListener('click', place47);
  $('#btnEndTurn').addEventListener('click', endTurn);
  $('#btnStart').addEventListener('click', ()=>{
    const rB=((Math.random()*6)|0)+1, rR=((Math.random()*6)|0)+1;
    const first = (rB===rR) ? (Math.random()<.5?'blue':'red') : (rB>rR?'blue':'red');
    state.firstOrder=first; state.active=first;
    state.phase='actions'; state.freeMoveRemaining=1;
    log(`Jet 🔵=${rB}, 🔴=${rR}. ${first==='blue'?'Bleu':'Rouge'} commence. Immunité pour l'adversaire.`);
    renderTop(); renderHands();
  });

  
  // Ready buttons for setup
  const btnReadyBlue = document.getElementById('btnReadyBlue');
  const btnReadyRed  = document.getElementById('btnReadyRed');
  function updateReadyButtons(){
    if(state.setup.done){ btnReadyBlue.style.display='none'; btnReadyRed.style.display='none'; return; }
    const blueOnBoard = state.pieces.blue.pieces.filter(u=>u.cell).length;
    const redOnBoard  = state.pieces.red.pieces.filter(u=>u.cell).length;
    btnReadyBlue.disabled = (blueOnBoard<5) || state.setup.blue.ready;
    btnReadyRed.disabled  = (redOnBoard<5)  || state.setup.red.ready;
  }
  btnReadyBlue.addEventListener('click', ()=>{ state.setup.blue.ready=true; log('🔵 prêt.'); checkBothReady(); updateReadyButtons(); });
  btnReadyRed .addEventListener('click', ()=>{ state.setup.red.ready =true; log('🔴 prêt.'); checkBothReady(); updateReadyButtons(); });
  function checkBothReady(){
    if(state.setup.blue.ready && state.setup.red.ready && !state.setup.done){
      state.setup.done = true;
      // Hide ready buttons and place tiles automatically
      document.getElementById('btnStart').style.display='inline-block';
      btnReadyBlue.style.display='none'; btnReadyRed.style.display='none';
      place47();
      // Auto-roll to determine first player
      const rB=((Math.random()*6)|0)+1, rR=((Math.random()*6)|0)+1;
      const first = (rB===rR) ? (Math.random()<.5?'blue':'red') : (rB>rR?'blue':'red');
      state.firstOrder=first; state.active=first;
      state.phase='actions'; state.freeMoveRemaining=1;
      log(`Jet 🔵=${rB}, 🔴=${rR}. ${first==='blue'?'Bleu':'Rouge'} commence. Immunité pour l'adversaire.`);
      renderTop(); renderHands(); renderBoard();
    }
  }

  // ===== Init =====
  initGame();
  </script>
<script type="module">
/* KOIKOS: Firebase realtime networking */
(async () => {
  try {
    // OPTIONAL: Fill your Firebase Web config here to enable online 2‑player mode.
    // You can find this in Firebase Console > Project Settings > "Your apps" (Web).
    const firebaseConfig = {
      apiKey: "PASTE_API_KEY",
      authDomain: "PASTE_PROJECT.firebaseapp.com",
      projectId: "PASTE_PROJECT_ID",
      storageBucket: "PASTE_PROJECT.appspot.com",
      messagingSenderId: "PASTE_SENDER_ID",
      appId: "PASTE_APP_ID"
    };
    if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "PASTE_API_KEY") {
      console.warn("Firebase not configured. Multiplayer disabled until you paste your firebaseConfig.");
      return;
    }

    const { initializeApp } = await import("https://www.gstatic.com/firebasejs/10.12.1/firebase-app.js");
    const { getAuth, signInAnonymously } = await import("https://www.gstatic.com/firebasejs/10.12.1/firebase-auth.js");
    const { getFirestore, doc, onSnapshot, setDoc, getDoc } = await import("https://www.gstatic.com/firebasejs/10.12.1/firebase-firestore.js");

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    await signInAnonymously(auth);

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || Math.random().toString(36).slice(2, 8).toUpperCase();
    if (!params.get("room")) {
      history.replaceState({}, "", `?room=${roomId}`);
    }

    // Small banner in log
    try { document.getElementById("log")?.insertAdjacentHTML("beforeend", `<div>🌐 Salle en ligne: <b>${roomId}</b></div>`); } catch {}

    const roomRef = doc(db, "rooms", roomId);
    const myId = crypto.randomUUID();
    let lastSeenVer = 0;
    let pushing = false;
    let pushPending = false;

    function serialize(s) {
      // Strip UI-only/transient fields
      const { inProgress, selected, lastLanding, tileRevealedThisTurn, ...rest } = s;
      return {
        ...rest,
        blocks: Array.from(s.blocks || []),
        tiles: s.tiles || {},
      };
    }

    function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

    function hydrate(payload) {
      try {
        // Merge payload back into local state
        const data = deepClone(payload);
        if (!data) return;
        // Preserve some transient flags locally (optional)
        // Assign core fields
        state.turn   = data.turn;
        state.active = data.active;
        state.phase  = data.phase;
        state.firstTurnMode = data.firstTurnMode;
        state.firstOrder    = data.firstOrder;
        state.immunity      = data.immunity;
        state.blocks = new Set(data.blocks || []);
        state.tiles  = data.tiles || {};
        state.played = data.played || 0;
        state.freeMoveRemaining = data.freeMoveRemaining || 0;
        state.flags  = data.flags || {};
        state.setup  = data.setup || state.setup;
        state.pieces = data.pieces || state.pieces;
        state.discardLeft = data.discardLeft || 0;
        state.gameOver = !!data.gameOver;
        // Repaint
        if (typeof renderBoard === "function") renderBoard();
        if (typeof renderHands === "function") renderHands();
        if (typeof updateDeckUI === "function") updateDeckUI();
        if (typeof renderTop === "function") renderTop();
      } catch (e) {
        console.warn("Hydration error:", e);
      }
    }

    async function pushState() {
      try {
        if (pushing) { pushPending = true; return; }
        pushing = true;
        const ver = Date.now();
        await setDoc(roomRef, { ver, sender: myId, state: serialize(state) });
        lastSeenVer = ver;
      } catch (e) {
        console.warn("Push error:", e);
      } finally {
        pushing = false;
        if (pushPending) { pushPending = false; pushState(); }
      }
    }
    const debouncedPush = (()=>{
      let t; return ()=>{ clearTimeout(t); t=setTimeout(pushState, 250); };
    })();

    // Listen to remote changes
    onSnapshot(roomRef, (snap) => {
      const d = snap.data();
      if (!d) return;
      if (d.sender === myId) return;      // ignore own writes
      if (!d.ver || d.ver <= lastSeenVer) return;
      lastSeenVer = d.ver;
      hydrate(d.state);
    });

    // Bootstrap: if no doc yet, write initial state once
    try {
      const snap = await getDoc(roomRef);
      if (!snap.exists()) {
        await setDoc(roomRef, { ver: Date.now(), sender: myId, state: serialize(state) });
        lastSeenVer = Date.now();
      } else {
        const d = snap.data();
        if (d && d.state) hydrate(d.state);
      }
    } catch {}

    // Heuristic: push after any user action
    document.addEventListener("click", debouncedPush, true);
    document.addEventListener("keydown", debouncedPush, true);
    // Also push on interval as a safety net
    setInterval(pushState, 4000);

    // Expose
    window.pushState = pushState;
    window.firebaseReady = true;
    console.log("Multiplayer ready in room", roomId);
  } catch (e) {
    console.warn("Firebase networking disabled:", e);
  }
})();
</script>

<!-- Multiplayer sync (Firebase) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
  import { getDatabase, ref, set, onValue, serverTimestamp, onDisconnect } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";

  // ===== Firebase config (Spark gratuit) =====
  const firebaseConfig = {
    authDomain: "la-forteresse-1v1.firebaseapp.com",
    databaseURL: "https://la-forteresse-1v1-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "la-forteresse-1v1",
    storageBucket: "la-forteresse-1v1.firebasestorage.app",
    messagingSenderId: "1054155576025",
    appId: "1:1054155576025:web:b33640206bd45ebe4564c8",
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getDatabase(app);

  // ===== Room helpers =====
  function getRoomId(){
    const h = (location.hash || "").replace(/^#/, "").trim();
    return h || "public";
  }
  function setRoomId(id){
    location.hash = id;
  }

  // ===== Serialize / Apply subset of game state =====
  function serializeGame(){
    try{
      return {
        turn: state?.turn ?? 0,
        active: state?.active ?? "blue",
        phase: state?.phase ?? "préparation",
        blue: {
          fortHP: state?.pieces?.blue?.fortHP ?? 10,
          pieces: (state?.pieces?.blue?.pieces || []).map(u => ({ id:u.id, cell:u.cell || null, hp:u.hp ?? 2 }))
        },
        red: {
          fortHP: state?.pieces?.red?.fortHP ?? 10,
          pieces: (state?.pieces?.red?.pieces || []).map(u => ({ id:u.id, cell:u.cell || null, hp:u.hp ?? 2 }))
        },
        blocks: Array.from(state?.blocks || []),
        // Tiles (without hidden info except "revealed" flag + kind)
        tiles: Object.fromEntries(
          Object.entries(state?.tiles || {}).map(([k,t]) => [k, { kind: t.kind, revealed: !!t.revealed }])
        ),
        rev: Date.now()
      };
    }catch(e){
      console.warn("serializeGame failed", e);
      return { rev: Date.now() };
    }
  }

  function applyGame(s){
    if(!s) return;
    try{
      state.turn   = s.turn ?? state.turn;
      state.active = s.active ?? state.active;
      state.phase  = s.phase ?? state.phase;
      if(s.blue){
        state.pieces.blue.fortHP = s.blue.fortHP ?? state.pieces.blue.fortHP;
        // map by id
        const idx = Object.fromEntries((state.pieces.blue.pieces || []).map((u,i)=>[u.id,i]));
        (s.blue.pieces || []).forEach(sp => {
          const i = idx[sp.id];
          if(i !== undefined){
            state.pieces.blue.pieces[i].cell = sp.cell ?? state.pieces.blue.pieces[i].cell;
            state.pieces.blue.pieces[i].hp   = sp.hp   ?? state.pieces.blue.pieces[i].hp;
          }
        });
      }
      if(s.red){
        state.pieces.red.fortHP = s.red.fortHP ?? state.pieces.red.fortHP;
        const idx = Object.fromEntries((state.pieces.red.pieces || []).map((u,i)=>[u.id,i]));
        (s.red.pieces || []).forEach(sp => {
          const i = idx[sp.id];
          if(i !== undefined){
            state.pieces.red.pieces[i].cell = sp.cell ?? state.pieces.red.pieces[i].cell;
            state.pieces.red.pieces[i].hp   = sp.hp   ?? state.pieces.red.pieces[i].hp;
          }
        });
      }
      // blocks / tiles
      state.blocks = new Set(s.blocks || []);
      state.tiles  = s.tiles  || state.tiles;

      // Render after apply
      if(typeof renderBoard === "function") renderBoard();
      if(typeof renderHands === "function") renderHands();
      if(typeof renderTop === "function") renderTop();
    }catch(e){
      console.warn("applyGame failed", e);
    }
  }

  // ===== Sync wiring =====
  let lastRev = 0;
  let isApplyingRemote = false;
  let currentRoomRef = null;

  function broadcastNow(){
    if(isApplyingRemote) return; // don't echo remote updates
    const payload = serializeGame();
    lastRev = payload.rev;
    if(currentRoomRef){
      set(currentRoomRef, payload);
    }
  }

  // Debounce helper to avoid flooding writes
  let saveTimer = null;
  function broadcastDebounced(){
    if(isApplyingRemote) return;
    clearTimeout(saveTimer);
    saveTimer = setTimeout(broadcastNow, 120);
  }

  // Monkey-patch renderBoard to auto-broadcast after local changes
  if(typeof renderBoard === "function"){
    const _renderBoard = renderBoard;
    window.renderBoard = function(){
      _renderBoard();
      broadcastDebounced();
    }
  }

  // Also broadcast on end-turn button clicks if present
  document.addEventListener("click", (ev)=>{
    const id = (ev.target && ev.target.id) ? ev.target.id : "";
    if(id === "btnEndTurn" || id === "btnReadyBlue" || id === "btnReadyRed"){
      setTimeout(broadcastNow, 50);
    }
  });

  // ===== Start auth + listeners =====
  signInAnonymously(auth).catch(()=>{});
  onAuthStateChanged(auth, (u)=>{
    if(!u) return;
    const rid = getRoomId();
    const base = ref(db, `rooms/${rid}`);
    // presence
    const pRef = ref(db, `rooms/${rid}/players/${u.uid}`);
    set(pRef, { joinedAt: serverTimestamp() });
    onDisconnect(pRef).remove();

    // state
    currentRoomRef = ref(db, `rooms/${rid}/state`);
    onValue(currentRoomRef, (snap)=>{
      const data = snap.val();
      if(!data) return;
      if(data.rev && data.rev <= lastRev) return; // ignore our own echo
      isApplyingRemote = true;
      applyGame(data);
      lastRev = data.rev || Date.now();
      isApplyingRemote = false;
    });

    // If no state yet, publish our current one as initial
    onValue(currentRoomRef, (snap)=>{
      if(!snap.exists()){
        broadcastNow();
      }
    }, { onlyOnce: true });

    // Generate a short room id if none in URL
    if(!location.hash){
      setRoomId(crypto.randomUUID().slice(0,6));
    }
  });
</script>

</body>
</html>
