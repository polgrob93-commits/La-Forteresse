<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>La Forteresse â€” Prototype final</title>
  <style>
    :root{ --grid:9; --bg:#0f1116; --panel:#151a23; --text:#e8eef7; --muted:#8ea0bf;
           --tile:#1b2230; --tile2:#1f2736; --orange:#e6a23c; --blue:#2c7be5; --red:#e55353; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(120deg,#0f1116,#0c111a);color:var(--text);
         font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .app{max-width:1240px;margin:14px auto;padding:0 12px;display:grid;gap:12px;
         grid-template-columns:300px 1fr 320px}
    .card{background:var(--panel);border:1px solid #232a3b;border-radius:16px;overflow:hidden;
          box-shadow:0 12px 28px rgba(0,0,0,.35)}
    .card h2{margin:0;padding:10px 12px;font-size:16px;border-bottom:1px solid #1e2533;background:#121722}
    .pad{padding:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .sep{height:1px;background:#20283b;margin:10px 0}
    .pill{display:inline-flex;align-items:center;gap:6px;background:#101827;border:1px solid #253045;
          border-radius:999px;padding:6px 10px}
    .btn{appearance:none;border:1px solid #2a3246;background:#192031;color:#cfe1ff;padding:8px 12px;border-radius:10px;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,#3563c9,#234db0);border-color:#2048a0;color:#fff;font-weight:600}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .log{height:220px;overflow:auto;font-family:ui-monospace,Menlo,Consolas,monospace;background:#111622;
         border-radius:10px;padding:10px;border:1px solid #222a3a}

    /* Board */
    .board-wrap{display:grid;place-items:center;padding:12px}
    #board{display:grid;grid-template-columns:repeat(9,1fr);grid-template-rows:repeat(9,1fr);
           gap:2px;width:96vmin;max-width:680px;aspect-ratio:1/1;background:#0b0f16;border:1px solid #1c2433;border-radius:14px;padding:8px}
    .cell{border-radius:8px;position:relative;display:grid;place-items:center;user-select:none}
    .cell.play{background:linear-gradient(180deg,var(--tile),var(--tile2));border:1px solid #24304a}
    .cell.invalid{background:transparent;border:1px dashed #1c2233;opacity:.25}
    .cell.orange{outline:2px solid var(--orange)}
    .cell.bzone{box-shadow:inset 0 0 0 2px rgba(44,123,229,.35)}
    .cell.rzone{box-shadow:inset 0 0 0 2px rgba(229,83,83,.35)}
    .coord{position:absolute;right:4px;bottom:4px;font-size:10px;color:#8a94ab;opacity:.7}

    /* Highlight classes */
    .cell.hl { outline:3px solid #fff; outline-offset:-3px; }
    .cell.move-ok { box-shadow:inset 0 0 0 3px rgba(111, 255, 145, .9); cursor:pointer; }
    .cell.move-bad{ box-shadow:inset 0 0 0 3px rgba(255, 111, 111, .7); }
    .cell.target-ok{ box-shadow:inset 0 0 0 3px rgba(255, 215, 111, .9); cursor:pointer; }

    /* blocks: small brown circles */
    .block{width:40%;height:40%;border-radius:50%;background:linear-gradient(180deg,#5a4a3f,#3e3028);}

    /* Pieces, forts, blocks */
    .piece, .fort, .block{display:grid;place-items:center;font-weight:700;color:#0b0f16;border:2px solid rgba(0,0,0,.35);box-shadow:0 6px 12px rgba(0,0,0,.35)}
    .piece{width:70%;height:70%;border-radius:50%}
    .fort{width:80%;height:80%;border-radius:12px;font-weight:800}
    .piece.blue{background:linear-gradient(180deg,#3c9cff,#2c7be5)}
    .piece.red{background:linear-gradient(180deg,#ff6767,#e55353)}
    .fort.blue{background:linear-gradient(180deg,#afd3ff,#7ab6ff)}
    .fort.red{background:linear-gradient(180deg,#ffb1b1,#ff7e7e)}
    .hp{position:absolute;bottom:-10px;left:50%;transform:translateX(-50%);font-size:11px;color:#cfd7ea;background:#121722;border:1px solid #1d2433;border-radius:8px;padding:2px 6px}

    .hand{display:grid;gap:8px}
    .cardui{background:#141a22;border:1px solid #232a3a;border-radius:12px;padding:10px}
    .cardui h4{margin:0 0 6px;font-size:13px}
    .small{font-size:11px;color:var(--muted)}
    .playbtn{margin-top:8px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  </style>
</head>
<body>
  <div class="app">
    <aside class="card">
      <h2>Ã‰tat de la partie</h2>
      <div class="pad">
        <div class="row" style="justify-content:space-between">
          <div class="pill"><strong>Tour:</strong> <span id="turnLabel">0</span></div>
          <button id="btnStart" class="btn primary">DÃ©terminer le 1er joueur</button>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Forteresse ðŸ”µ</h4>
            <div>PV: <span id="blueHP">7</span> (A9)</div>
          </div>
          <div class="cardui">
            <h4>Forteresse ðŸ”´</h4>
            <div>PV: <span id="redHP">7</span> (I1)</div>
          </div>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Phase</h4>
            <div id="phase" class="small">prÃ©paration</div>
          </div>
          <div class="cardui">
            <h4>ImmunitÃ© (tour 1)</h4>
            <div class="small">J1: <span id="im1">âœ”</span> Â· J2: <span id="im2">âœ”</span></div>
          </div>
        </div>
      <div class="sep"></div>
      <!-- Affichage du nombre de cartes jouÃ©es ce tour -->
      <div class="cardui">
        <h4>Cartes jouÃ©es</h4>
        <div class="small" id="cardsPlayed">0/3</div>
      </div>
        <div class="sep"></div>
        <div class="cardui">
          <h4>Actions rapides</h4>
          <div class="row">
            <button class="btn" id="btnPlaceTiles">Placer 47 tuiles</button>
            <button class="btn" id="btnReset">RÃ©initialiser</button>
          </div>
        </div>
        <div class="sep"></div>
        <div class="cardui">
          <h4>Journal</h4>
          <div id="log" class="log"></div>
        </div>
      </div>
    </aside>

    <main class="card">
      <h2>Plateau</h2>
      <div class="board-wrap">
        <div id="board"></div>
      </div>
    </main>

    <aside class="card">
      <h2>Main & Pioches</h2>
      <div class="pad">
        <div class="row" style="justify-content:space-between">
          <div class="pill">Joueur actif: <strong id="activePlayer">â€”</strong></div>
          <button id="btnEndTurn" class="btn">Fin de tour</button>
        </div>
        <div class="sep"></div>
        <div class="grid2">
          <div class="cardui">
            <h4>Main (ðŸ”µ)</h4>
            <div id="handBlue" class="hand"></div>
          </div>
          <div class="cardui">
            <h4>Main (ðŸ”´)</h4>
            <div id="handRed" class="hand"></div>
          </div>
        </div>
        <div class="sep"></div>
        <div class="grid3">
          <div class="cardui">
            <h4>Pioches</h4>
            <div class="small">ðŸ”µ: <span id="deckB">â€”</span> Â· ðŸ”´: <span id="deckR">â€”</span></div>
            <div class="small">DÃ©fausses â€” ðŸ”µ: <span id="discB">0</span> Â· ðŸ”´: <span id="discR">0</span></div>
          </div>
          <div class="cardui">
            <h4>Tuiles</h4>
            <div class="small">PlacÃ©es: <span id="tilesCount">0</span> / 47</div>
          </div>
          <div class="cardui">
            <h4>Blocs</h4>
            <div class="small"><span id="blocksActive">0</span> / 6</div>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <script>
  // ===== Constantes plateau =====
  const GRID=9, COLS="ABCDEFGHI";
  const forbidden = new Set(["A1","B1","C1","A2","B2","C2","A3","B3","G9","H9","I9","G8","H8","I8","H7","I7"]);
  const valid = new Set([
    "A4","A5","A6","A7","A8",
    "B4","B5","B6","B7","B8","B9",
    "C3","C4","C5","C6","C7","C8","C9",
    "D1","D2","D3","D4","D5","D6","D7","D8","D9",
    "E1","E2","E3","E4","E5","E6","E7","E8","E9",
    "F1","F2","F3","F4","F5","F6","F7","F8","F9",
    "G1","G2","G3","G4","G5","G6","G7",
    "H1","H2","H3","H4","H5","H6",
    "I2","I3","I4","I5","I6"
  ]);
  const ORANGE = new Set(["D5","E4","E5","E6","F5"]);
  const RED_SPAWN = new Set(["G1","G2","G3","H1","H2","H3","I2","I3"]);
  const BLUE_SPAWN= new Set(["A8","A7","B9","B8","B7","C9","C8","C7"]);
  const FORT_BLUE="A9", FORT_RED="I1";

  const $ = (s)=>document.querySelector(s);
  const board=$("#board"), logEl=$("#log");

  const state = {
    turn:0, active:'blue', phase:'prÃ©paration',
    firstTurnMode:true, firstOrder:null, immunity:{p1:true,p2:true},
    blocks:new Set(),
    tiles:{}, // cell -> {key,kind,revealed}
    selected:null,
    played:0,
    freeMoveRemaining:0,
    inProgress:null, // {mode:'MOVE', color, unitId, cardId, remaining}
    discardLeft:0, // number of cards the player may still discard in the preparation phase
    pieces:{
      blue:{fortHP:7, pieces:[], hand:[], deck:[], discard:[]},
      red :{fortHP:7, pieces:[], hand:[], deck:[], discard:[]},
    },
    flags:{} // e.g. extraCard, drawTo4, noMagic, etc.
  };

  // ===== Helpers =====
  function toAlg(c,r){ return COLS[c]+(r+1); }
  function fromAlg(a){ return {c:COLS.indexOf(a[0]), r:+a.slice(1)-1}; }
  function log(t){ const p=document.createElement('div'); p.textContent=t; logEl.appendChild(p); logEl.scrollTop=logEl.scrollHeight; }
  function neighbors4(a){ const {c,r}=fromAlg(a); const outs=[]; [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dc,dr])=>{ const nc=c+dc, nr=r+dr; if(nc>=0&&nc<GRID&&nr>=0&&nr<GRID){ const x=toAlg(nc,nr); if(!forbidden.has(x)) outs.push(x); }}); return outs; }
  function isAdjacent4(a,b){ return neighbors4(a).includes(b); }
  function isLine(a,b){
    const A=fromAlg(a), B=fromAlg(b); const dc=Math.sign(B.c-A.c), dr=Math.sign(B.r-A.r);
    if(!(A.c===B.c || A.r===B.r || Math.abs(B.c-A.c)===Math.abs(B.r-A.r))) return null;
    const seq=[]; let c=A.c+dc, r=A.r+dr; while(!(c===B.c && r===B.r)){ seq.push(toAlg(c,r)); c+=dc; r+=dr; } return seq;
  }
  function isFortCell(cell){ return cell===FORT_BLUE || cell===FORT_RED; }
  function isLOS(a,b){ const between=isLine(a,b); if(!between) return false;
    return between.every(c=>!state.blocks.has(c) && !getPieceAt(c) && !isFortCell(c));
  }
  function getPieceAt(cell){
    // Exclude fort positions; forts are handled separately
    if(isFortCell(cell)) return null;
    for(const color of ['blue','red']){
      const u=state.pieces[color].pieces.find(p=>p.cell===cell);
      if(u) return {color,unit:u};
    }
    return null;
  }
  function findUnit(color,id){ return state.pieces[color].pieces.find(u=>u.id===id); }
  function canStep(from,to){
    if(!from||from===to) return false;
    if(isFortCell(to)) return false;
    if(!valid.has(to)||state.blocks.has(to)||getPieceAt(to)) return false;
    return isAdjacent4(from,to);
  }

  // ===== Board build =====
  function buildGrid(){
    board.innerHTML='';
    for(let r=GRID-1;r>=0;r--){
      for(let c=0;c<GRID;c++){
        const alg=toAlg(c,r);
        const cell=document.createElement('div'); cell.className='cell '+(forbidden.has(alg)?'invalid':'play'); cell.dataset.coord=alg;
        if(ORANGE.has(alg)) cell.classList.add('orange');
        if(RED_SPAWN.has(alg)) cell.classList.add('rzone');
        if(BLUE_SPAWN.has(alg)) cell.classList.add('bzone');
        const q=document.createElement('div'); q.className='coord'; q.textContent=alg; cell.appendChild(q);
        cell.addEventListener('click', () => onCellClick(alg, cell));
        board.appendChild(cell);
      }
    }
  }

  function renderBoard(){
    // Clear and re-render pieces, forts, blocks
    document.querySelectorAll('.cell').forEach(cell=>{
      // remove non-coord children
      [...cell.children].forEach(ch=>{ if(!ch.classList.contains('coord')) ch.remove(); });
      // update block state visually
      cell.classList.toggle('blocked', state.blocks.has(cell.dataset.coord));
    });
    // Forts
    const fortPositions=[[FORT_BLUE,'blue',state.pieces.blue.fortHP],[FORT_RED,'red',state.pieces.red.fortHP]];
    fortPositions.forEach(([pos,color,hp])=>{
      const cell=document.querySelector(`.cell[data-coord="${pos}"]`);
      if(cell){ const f=document.createElement('div'); f.className=`fort ${color}`; f.textContent='F';
        const h=document.createElement('div'); h.className='hp'; h.textContent=`${hp} PV`;
        cell.appendChild(f); cell.appendChild(h);
      }
    });
    // Blocks
    state.blocks.forEach(pos=>{
      const cell=document.querySelector(`.cell[data-coord="${pos}"]`);
      if(cell){ const b=document.createElement('div'); b.className='block'; cell.appendChild(b); }
    });
    // Pieces
    ['blue','red'].forEach(color=>{
      state.pieces[color].pieces.forEach(u=>{
        if(!u.cell) return;
        const cell=document.querySelector(`.cell[data-coord="${u.cell}"]`);
        if(cell){ const p=document.createElement('div'); p.className=`piece ${color}`; p.textContent=u.hp;
          p.title=`${color} ${u.id}`;
          cell.appendChild(p);
        }
      });
    });
    // Apply highlights for move/free move
    applyHighlights();
  }

  // ===== Decks & hands =====
  function buildDeck26(){
    const deck=[];
    deck.push(...Array(3).fill({t:'MOVE',n:2}));
    deck.push(...Array(3).fill({t:'MOVE',n:3}));
    deck.push(...Array(2).fill({t:'MOVE',n:4}));
    deck.push(...Array(2).fill({t:'MOVE',n:5}));
    deck.push(...Array(6).fill({t:'MELEE_SWAP'}));
    deck.push(...Array(4).fill({t:'RANGE_TP'}));
    deck.push(...Array(3).fill({t:'HEAL_REINFORCE'}));
    deck.push(...Array(3).fill({t:'BLOCK_UNBLOCK'}));
    return deck.map((c,i)=>({...c,id:`C${Math.random().toString(36).slice(2,8)}${i}`}));
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function reshuffleIfNeeded(P){ if(P.deck.length===0 && P.discard.length){ P.deck=shuffle(P.discard.splice(0)); log('ðŸ”„ Re-mÃ©lange de la dÃ©fausse dans la pioche.'); } }
  function draw(color,n){ const P=state.pieces[color]; while(n-->0){ if(P.deck.length===0) reshuffleIfNeeded(P); if(P.deck.length===0) break; P.hand.push(P.deck.pop()); } updateDeckUI(); }
  function drawTo(color,cap){ const P=state.pieces[color]; while(P.hand.length<cap){ if(P.deck.length===0) reshuffleIfNeeded(P); if(P.deck.length===0) break; P.hand.push(P.deck.pop()); } updateDeckUI(); }
  function updateDeckUI(){
    // Update deck display to show remaining / total (deck + hand + discard)
    const blueTotal = state.pieces.blue.deck.length + state.pieces.blue.hand.length + state.pieces.blue.discard.length;
    const redTotal  = state.pieces.red.deck.length  + state.pieces.red.hand.length  + state.pieces.red.discard.length;
    $('#deckB').textContent = `${state.pieces.blue.deck.length} / ${blueTotal}`;
    $('#deckR').textContent = `${state.pieces.red.deck.length} / ${redTotal}`;
    $('#discB').textContent=state.pieces.blue.discard.length;
    $('#discR').textContent=state.pieces.red.discard.length;
  }
  function renderHands(){
    function side(color,target){
      const P=state.pieces[color]; target.innerHTML='';
      P.hand.forEach((card,idx)=>{
        const box=document.createElement('div'); box.className='cardui';
        const h=document.createElement('h4');
        switch(card.t){ case 'MOVE': h.textContent=`DÃ©placement ${card.n}`; break;
          case 'MELEE_SWAP': h.textContent='CAC / Ã‰change'; break;
          case 'RANGE_TP': h.textContent='Attaque Ã  distance / TÃ©lÃ©portation'; break;
          case 'HEAL_REINFORCE': h.textContent='Soin / Renfort'; break;
          case 'BLOCK_UNBLOCK': h.textContent='Blocage / DÃ©blocage'; break;
          default: h.textContent='Carte'; }
        box.appendChild(h);
        const s=document.createElement('div'); s.className='small'; s.textContent='#'+card.id; box.appendChild(s);
        const b=document.createElement('button'); b.className='btn playbtn'; b.textContent='Jouer';
        // dÃ©sactiver le bouton selon l'Ã©tat du jeu
        const limit = 3 + (state.flags.extraCard ? state.flags.extraCard : 0);
        // Ne pas autoriser Ã  jouer de carte si ce n'est pas la phase d'actions
        if(state.phase !== 'actions' || state.active!==color || state.played >= limit || state.gameOver) b.disabled=true;
        b.addEventListener('click', ()=> playCard(color, idx));
        box.appendChild(b);
        // si cette carte est un dÃ©placement en cours, proposer un bouton DÃ©fausser/Annuler
        if(card.t==='MOVE' && state.inProgress && state.inProgress.mode==='MOVE' && state.inProgress.cardId===card.id && !state.gameOver){
          const cancelBtn=document.createElement('button'); cancelBtn.className='btn playbtn'; cancelBtn.style.marginTop='4px';
          // Choisir le libellÃ© selon s'il reste tous les pas (annuler) ou non (dÃ©fausser)
          cancelBtn.textContent = (state.inProgress.remaining === state.inProgress.initial) ? 'Annuler' : 'DÃ©fausser';
          cancelBtn.addEventListener('click', ()=>{
            if(state.inProgress && state.inProgress.remaining === state.inProgress.initial){
              cancelMoveCard();
            } else {
              commitMoveInProgress();
            }
            renderBoard();
          });
          box.appendChild(cancelBtn);
        }
        // En phase de prÃ©paration, proposer un bouton DÃ©fausser pour chaque carte tant qu'il reste des dÃ©fausses
        if(state.phase === 'prÃ©paration' && state.active === color && state.discardLeft > 0 && !state.inProgress && !state.gameOver){
          const discardBtn=document.createElement('button'); discardBtn.className='btn playbtn'; discardBtn.style.marginTop='4px'; discardBtn.textContent='DÃ©fausser';
          discardBtn.addEventListener('click', ()=>{
            const P=state.pieces[color]; const cardIndex=P.hand.findIndex(c=>c.id===card.id);
            if(cardIndex>=0){ const [c]=P.hand.splice(cardIndex,1); if(c) P.discard.push(c); }
            state.discardLeft--;
            renderHands(); updateDeckUI();
          });
          box.appendChild(discardBtn);
        }
        target.appendChild(box);
      });
    }
    side('blue', $('#handBlue')); side('red', $('#handRed'));
  }

  // ===== Highlights =====
  function clearHighlights(){ document.querySelectorAll('.cell').forEach(cell=>{
    cell.classList.remove('move-ok','move-bad','hl','target-ok'); }); }
  function applyHighlights(){
    clearHighlights();
    // highlight selected unit
    if(state.selected){ const cell=document.querySelector(`.cell[data-coord="${state.selected.cell}"]`); if(cell) cell.classList.add('hl'); }
    // highlight move card path if in progress
    if(state.inProgress){
      if(state.inProgress.mode==='MOVE'){
        const {color, unitId} = state.inProgress;
        const unit=findUnit(color, unitId);
        if(unit && unit.cell){
          neighbors4(unit.cell).forEach(coord=>{
            const cell=document.querySelector(`.cell[data-coord="${coord}"]`);
            if(!cell) return;
            if(canStep(unit.cell,coord)) cell.classList.add('move-ok'); else cell.classList.add('move-bad');
          });
          const here=document.querySelector(`.cell[data-coord="${unit.cell}"]`); if(here) here.classList.add('hl');
        }
      } else if(state.inProgress.mode==='BLOCK'){
        // highlight candidates for block placement
        state.inProgress.candidates.forEach(coord=>{
          const cell=document.querySelector(`.cell[data-coord="${coord}"]`);
          if(cell) cell.classList.add('target-ok');
        });
        // highlight selected unit
        const u=findUnit(state.inProgress.color, state.inProgress.unitId);
        if(u && u.cell){ const cell=document.querySelector(`.cell[data-coord="${u.cell}"]`); if(cell) cell.classList.add('hl'); }
      }
    } else if(state.selected && state.freeMoveRemaining>0){
      // free move neighbours
      const unit=findUnit(state.selected.color, state.selected.id);
      if(unit && unit.cell){ neighbors4(unit.cell).forEach(coord=>{
        const cell=document.querySelector(`.cell[data-coord="${coord}"]`);
        if(!cell) return;
        if(canStep(unit.cell,coord)) cell.classList.add('move-ok'); else cell.classList.add('move-bad');
      });
      const here=document.querySelector(`.cell[data-coord="${unit.cell}"]`); if(here) here.classList.add('hl'); }
    }
  }

  // ===== Game init =====
  function initGame(){
    Object.assign(state,{
      turn:0, active:'blue', phase:'prÃ©paration',
      firstTurnMode:true, firstOrder:null, immunity:{p1:true,p2:true},
      blocks:new Set(), tiles:{}, selected:null, played:0, flags:{}, freeMoveRemaining:0, inProgress:null,
      discardLeft:0,
      gameOver:false
    });
    state.pieces.blue={fortHP:7, pieces:[], hand:[], deck:shuffle(buildDeck26()), discard:[]};
    state.pieces.red ={fortHP:7, pieces:[], hand:[], deck:shuffle(buildDeck26()), discard:[]};
    // place pions: 5 in spawn, 2 reserve
    shuffle([...BLUE_SPAWN]).slice(0,5).forEach((cell,i)=>state.pieces.blue.pieces.push({id:`B${i+1}`,cell,hp:2}));
    state.pieces.blue.pieces.push({id:'B6',cell:null,hp:2}); state.pieces.blue.pieces.push({id:'B7',cell:null,hp:2});
    shuffle([...RED_SPAWN]).slice(0,5).forEach((cell,i)=>state.pieces.red.pieces.push({id:`R${i+1}`,cell,hp:2}));
    state.pieces.red.pieces.push({id:'R6',cell:null,hp:2}); state.pieces.red.pieces.push({id:'R7',cell:null,hp:2});
    drawTo('blue',5); drawTo('red',5);
    buildGrid(); renderBoard(); renderHands(); renderTop();
    log('Nouvelle partie. Place 47 tuiles puis tire le premier joueur.');
  }

  // ===== Tiles =====
  function place47(){
    // Place 47 blank tiles on eligible cells (no spawn or forts)
    const all=[...valid].filter(c=>!RED_SPAWN.has(c)&&!BLUE_SPAWN.has(c)&&c!==FORT_BLUE&&c!==FORT_RED);
    const spots=shuffle(all).slice(0,47);
    state.tiles={}; spots.forEach(cell=>{ state.tiles[cell]={key:'BLANK',kind:'blank',revealed:false}; });
    updateTilesUI(); log('47 tuiles placÃ©es.');
  }
  function updateTilesUI(){ $('#tilesCount').textContent=Object.keys(state.tiles).length; }
  function revealTileIfAny(cell,color){
    const t=state.tiles[cell]; if(!t || t.revealed) return;
    t.revealed=true; log(`[Tuile] RÃ©vÃ©lÃ©e sur ${cell} (sans effet pour l'instant)`);
    updateTilesUI();
  }

  // ===== Card play =====
  function playCard(color, idx){
    // Ne rien faire si la partie est terminÃ©e
    if(state.gameOver) return;
    // Not your turn
    if(state.active!==color){ log('Ce n\'est pas votre tour.'); return; }
    // Only allow playing in phase 'actions'
    if(state.phase !== 'actions'){ log('Vous n\'Ãªtes pas en phase d\'actions.'); return; }
    // Respecter la limite de cartes jouÃ©es par tour (3 + bonus Ã©ventuel)
    const limit = 3 + (state.flags.extraCard ? state.flags.extraCard : 0);
    if(state.played >= limit){ log('Limite de cartes jouÃ©es atteinte.'); return; }
    // Si un dÃ©placement est en cours, le conclure ou l'annuler avant de jouer une autre carte
    if(state.inProgress){
      if(state.inProgress.mode==='MOVE'){
        const info = state.inProgress;
        // Si aucun pas n'a Ã©tÃ© effectuÃ© (remaining == initial), on annule simplement la carte
        if(info.remaining === info.initial){
          cancelMoveCard();
        } else {
          commitMoveInProgress();
        }
      } else {
        commitMoveInProgress();
      }
    }
    const P=state.pieces[color]; const card=P.hand[idx];
    if(!card) return;
    switch(card.t){
      case 'MOVE': playMoveCard(color, idx, card.n); break;
      case 'MELEE_SWAP': playMeleeOrSwap(color, idx); break;
      case 'RANGE_TP': playRangeOrTP(color, idx); break;
      case 'HEAL_REINFORCE': playHealOrReinforce(color, idx); break;
      case 'BLOCK_UNBLOCK': playBlockOrUnblock(color, idx); break;
      default: log('Carte non reconnue.');
    }
  }

  // ===== MOVE =====
  function playMoveCard(color, idx, steps){
    if(!state.selected || state.selected.color!==color){ log('SÃ©lectionnez un de vos pions pour jouer cette carte.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
    const P=state.pieces[color]; const cardObj=P.hand[idx]; const cardId=cardObj.id;
    // DÃ©marrer un dÃ©placement : stocker aussi le nombre de pas initial pour dÃ©tecter si aucun pas n'a Ã©tÃ© effectuÃ©
    state.inProgress={mode:'MOVE', color, unitId:unit.id, cardId, remaining:steps, initial:steps};
    applyHighlights();
    renderHands(); // mettre Ã  jour l'interface pour afficher le bouton DÃ©fausser
    log(`Carte DÃ©placement ${steps}: cliquez les cases vertes pour chaque pas.`);
  }
  function commitMoveInProgress(){
    if(!state.inProgress || state.inProgress.mode!=='MOVE') return;
    const {color, cardId}=state.inProgress;
    const P=state.pieces[color]; const idx=P.hand.findIndex(c=>c.id===cardId);
    if(idx>=0){ const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); }
    state.played++;
    state.inProgress=null;
    applyHighlights(); renderHands(); updateDeckUI();
  }

  // Annuler un dÃ©placement en cours sans le dÃ©fausser (aucun pas effectuÃ©)
  function cancelMoveCard(){
    if(!state.inProgress || state.inProgress.mode!=='MOVE') return;
    // remettre simplement l'Ã©tat sans dÃ©fausser la carte, ni augmenter le compteur de cartes jouÃ©es
    state.inProgress = null;
    applyHighlights();
    renderHands();
    // pas de changement dans la main ou la dÃ©fausse
  }

  function commitBlockInProgress(cell){
    // Ajouter un bloc Ã  l'emplacement spÃ©cifiÃ© et dÃ©fausser la carte
    const {color, cardId} = state.inProgress;
    state.blocks.add(cell);
    log(`Bloc placÃ© en ${cell}.`);
    const P = state.pieces[color];
    const idx = P.hand.findIndex(c => c.id === cardId);
    if(idx>=0){ const [card] = P.hand.splice(idx,1); if(card) P.discard.push(card); }
    state.played++;
    state.inProgress = null;
    applyHighlights(); renderHands(); updateDeckUI(); renderBoard();
  }

  // ===== MELEE / ECH =====
  function playMeleeOrSwap(color, idx){
    if(!state.selected || state.selected.color!==color){ log('SÃ©lectionnez un de vos pions pour jouer cette carte.'); return; }
    const choice=prompt('Entrez "CAC" pour attaque corps-Ã -corps ou "ECH" pour Ã©change:','CAC'); if(!choice) return;
    if(choice.toUpperCase()==='CAC'){ doMelee(color, idx); } else { doSwap(color, idx); }
  }
  function doMelee(color, idx){
    const unit=findUnit(color, state.selected.id);
    if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
    const target=prompt('Cible adjacente (coordonnÃ©e) :',''); if(!target) return;
    const alg=target.toUpperCase();
    // allow targeting fort
    if(!valid.has(alg) && alg!==FORT_BLUE && alg!==FORT_RED){ log('Cible invalide.'); return; }
    if(!isAdjacent4(unit.cell, alg)){ log('Cible non adjacente.'); return; }
    // attack fort or unit
    if(alg===FORT_BLUE || alg===FORT_RED){
      const fortColor=(alg===FORT_BLUE?'blue':'red');
      if(fortColor===color){ log('Impossible d\'attaquer sa propre forteresse.'); return; }
      rollDamageFort(fortColor);
    } else {
      const occ=getPieceAt(alg);
      if(!occ || occ.color===color){ log('Pas d\'ennemi Ã  cette case.'); return; }
      rollDamage(occ.unit, occ.color);
    }
    if(state.flags.pressure){ promptDiscard(color==='blue'?'red':'blue',1); state.flags.pressure=false; }
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }
  function doSwap(color, idx){
    if(state.flags.noMagic){ log('Anti-magie: Ã‰change impossible.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
    const target=prompt('Cible pour Ã©change (coordonnÃ©e):',''); if(!target) return;
    const alg=target.toUpperCase();
    if(!valid.has(alg) && alg!==FORT_BLUE && alg!==FORT_RED){ log('Cible invalide.'); return; }
    // cannot swap with fort
    if(alg===FORT_BLUE || alg===FORT_RED){ log('Impossible d\'Ã©changer avec une forteresse.'); return; }
    const occ=getPieceAt(alg);
    if(!occ){ log('Aucun pion sur cette case.'); return; }
    if(!isLOS(unit.cell, occ.unit.cell)){ log('Pas de ligne de vue.'); return; }
    if(occ.color!==color){
      // cannot swap with enemy in their spawn zone
      if((occ.color==='red' && RED_SPAWN.has(occ.unit.cell)) || (occ.color==='blue' && BLUE_SPAWN.has(occ.unit.cell))){ log('Interdit: ennemi dans sa zone de dÃ©part.'); return; }
    }
    // swap positions
    const tmp=unit.cell; unit.cell=occ.unit.cell; occ.unit.cell=tmp;
    revealTileIfAny(unit.cell,color); revealTileIfAny(occ.unit.cell,occ.color);
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }

  // ===== RANGE / TP =====
  function playRangeOrTP(color, idx){
    if(!state.selected || state.selected.color!==color){ log('SÃ©lectionnez un de vos pions.'); return; }
    const choice=prompt('Entrez "DIST" pour attaque Ã  distance ou "TP" pour tÃ©lÃ©portation:','DIST'); if(!choice) return;
    if(choice.toUpperCase()==='DIST'){ doRanged(color, idx); } else { doTeleport(color, idx); }
  }
  function doRanged(color, idx){
    if(state.flags.disarmed){ log('DÃ©sarmÃ©: pas d\'attaque.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
    const target=prompt('Cible (coordonnÃ©e, forteresse ou pion ennemi) :',''); if(!target) return;
    const alg=target.toUpperCase();
    if(alg!==FORT_BLUE && alg!==FORT_RED && !valid.has(alg)){ log('Cible invalide.'); return; }
    // cannot target adjacent cells
    if(isAdjacent4(unit.cell, alg)){ log('Cible adjacente: utilisez CAC.'); return; }
    const A=fromAlg(unit.cell);
    const B=fromAlg(alg===FORT_BLUE?FORT_BLUE: alg===FORT_RED?FORT_RED: alg);
    const dx=Math.abs(A.c-B.c), dy=Math.abs(A.r-B.r);
    const ortho=(dx===0||dy===0) && (dx+dy>=2 && dx+dy<=4);
    const diag=(dx===dy) && (dx>=1 && dx<=2);
    if(!(ortho||diag)){ log('PortÃ©e invalide (2-4 ortho ou 1-2 diag).'); return; }
    if(!isLOS(unit.cell, alg)){ log('Pas de ligne de vue.'); return; }
    // attack fort or unit
    if(alg===FORT_BLUE || alg===FORT_RED){
      const fortColor=(alg===FORT_BLUE?'blue':'red');
      if(fortColor===color){ log('Impossible de viser sa propre forteresse.'); return; }
      rollDamageFort(fortColor);
    } else {
      const occ=getPieceAt(alg);
      if(!occ || occ.color===color){ log('Pas d\'ennemi Ã  cette case.'); return; }
      rollDamage(occ.unit, occ.color);
    }
    if(state.flags.pressure){ promptDiscard(color==='blue'?'red':'blue',1); state.flags.pressure=false; }
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }
  function doTeleport(color, idx){
    if(state.flags.noMagic){ log('Anti-magie: pas de tÃ©lÃ©portation.'); return; }
    const unit=findUnit(color, state.selected.id);
    if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
    const target=prompt('Destination (coordonnÃ©e) :',''); if(!target) return;
    const alg=target.toUpperCase();
    if(!valid.has(alg)){ log('Destination invalide.'); return; }
    if(getPieceAt(alg) || state.blocks.has(alg) || isFortCell(alg)){ log('Case occupÃ©e, bloquÃ©e ou forteresse.'); return; }
    if(!isLOS(unit.cell, alg)){ log('Pas de ligne de vue.'); return; }
    if(color==='blue' && RED_SPAWN.has(alg)){ log('Interdit: zone rouge.'); return; }
    if(color==='red'  && BLUE_SPAWN.has(alg)){ log('Interdit: zone bleue.'); return; }
    unit.cell=alg;
    revealTileIfAny(alg,color);
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }

  // ===== HEAL / REINFORCE =====
  function playHealOrReinforce(color, idx){
    const choice=prompt('"SOIN" pour +2 PV forteresse (max 10) ou "RENF" pour renfort:','SOIN'); if(!choice) return;
    if(choice.toUpperCase()==='SOIN'){ const P=state.pieces[color]; P.fortHP=Math.min(10,P.fortHP+2); log('Forteresse '+color+' soignÃ©e (+2).'); }
    else {
      const P=state.pieces[color]; const reserve=P.pieces.find(u=>u.cell===null);
      if(!reserve){ log('Pas de pion en rÃ©serve.'); return; }
      const zone=color==='blue'? [...BLUE_SPAWN]:[...RED_SPAWN];
      const spot=zone.find(c=>!getPieceAt(c)); if(!spot){ log('Zone de dÃ©part pleine.'); return; }
      const onBoard=P.pieces.filter(u=>u.cell).length; if(onBoard>=7){ log('Trop de pions sur le plateau.'); return; }
      reserve.cell=spot; log(`Renfort: ${reserve.id} placÃ© en ${spot}.`);
    }
    const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
    renderHands(); updateDeckUI(); renderBoard();
  }

  // ===== BLOCK / UNBLOCK =====
  function playBlockOrUnblock(color, idx){
    const choice=prompt('"BLOC" pour placer un bloc, "DEBLOC" pour retirer:','BLOC'); if(!choice) return;
    if(choice.toUpperCase()==='BLOC'){
      if(state.blocks.size>=6){ log('Maximum de blocs actifs.'); return; }
      if(!state.selected || state.selected.color!==color){ log('SÃ©lectionnez un pion pour placer un bloc.'); return; }
      const unit=findUnit(color,state.selected.id);
      if(!unit || !unit.cell){ log('Pion hors plateau.'); return; }
      // dÃ©terminer les cases adjacentes valides pour placer un bloc
      const candidates = neighbors4(unit.cell).filter(c=> !state.blocks.has(c) && !getPieceAt(c) && !RED_SPAWN.has(c) && !BLUE_SPAWN.has(c) && !ORANGE.has(c) && !isFortCell(c));
      if(candidates.length===0){ log('Aucune case valide pour placer un bloc.'); return; }
      // mettre en surbrillance ces cases et passer en mode BLOCK
      const P=state.pieces[color]; const cardObj=P.hand[idx];
      state.inProgress={mode:'BLOCK', color, unitId:unit.id, cardId:cardObj.id, candidates};
      applyHighlights();
      log('SÃ©lectionnez une case jaune pour placer votre bloc.');
      return;
    } else {
      if(!state.selected || state.selected.color!==color){ log('SÃ©lectionnez un pion pour retirer un bloc.'); return; }
      const unit=findUnit(color,state.selected.id);
      if(!unit||!unit.cell){ log('Pion hors plateau.'); return; }
      const cand=neighbors4(unit.cell).find(c=>state.blocks.has(c));
      if(!cand){ log('Aucun bloc adjacent Ã  retirer.'); return; }
      state.blocks.delete(cand);
      log(`Bloc retirÃ© de ${cand}.`);
      const P=state.pieces[color]; const [card]=P.hand.splice(idx,1); if(card) P.discard.push(card); state.played++;
      renderHands(); updateDeckUI(); renderBoard();
      return;
    }
  }

  // ===== Combat & dÃ©gÃ¢ts =====
  function rollDamage(targetUnit, targetColor){
    const roll=((Math.random()*6)|0)+1; let dmg=(roll===1||roll===6)?2:1;
    if(state.flags.weakenCrit && (roll===1||roll===6)) dmg=1;
    targetUnit.hp-=dmg;
    log(`Jet ${roll} â†’ ${dmg} dÃ©gÃ¢t(s) sur ${targetColor} ${targetUnit.id}.`);
    if(targetUnit.hp<=0){ removeUnit(targetColor, targetUnit.id); }
    state.flags.weakenCrit=false;
    renderBoard();
  }
  function rollDamageFort(color){
    const roll=((Math.random()*6)|0)+1; let dmg=(roll===1||roll===6)?2:1;
    if(state.flags.weakenCrit && (roll===1||roll===6)) dmg=1;
    state.pieces[color].fortHP=Math.max(0, state.pieces[color].fortHP-dmg);
    log(`Jet ${roll} â†’ ${dmg} dÃ©gÃ¢t(s) sur forteresse ${color}.`);
    state.flags.weakenCrit=false;
    renderBoard();
    checkGameOver();
  }
  function removeUnit(color,id){ const P=state.pieces[color]; const idx=P.pieces.findIndex(u=>u.id===id); if(idx>-1){ P.pieces[idx].cell=null; P.pieces[idx].hp=2; log(`${color} ${id} retirÃ© du plateau.`); } }
  function promptDiscard(color,n){ const P=state.pieces[color]; while(n-->0 && P.hand.length){ P.discard.push(P.hand.pop()); } updateDeckUI(); renderHands(); }

  // ===== Zone orange damage =====
  function applyZoneDamage(){
    // Compute counts for both players
    const blueCount = state.pieces.blue.pieces.filter(u=>u.cell && ORANGE.has(u.cell)).length;
    const redCount  = state.pieces.red.pieces.filter(u=>u.cell && ORANGE.has(u.cell)).length;
    // Damage to red fort if blue dominates
    if(blueCount >= 3){
      const dmg=2;
      state.pieces.red.fortHP = Math.max(0, state.pieces.red.fortHP - dmg);
      log(`Zone orange : forteresse rouge -${dmg} PV.`);
    } else if(blueCount >= 2 && redCount <= 1){
      const dmg=1;
      state.pieces.red.fortHP = Math.max(0, state.pieces.red.fortHP - dmg);
      log(`Zone orange : forteresse rouge -${dmg} PV.`);
    }
    // Damage to blue fort if red dominates
    if(redCount >= 3){
      const dmg=2;
      state.pieces.blue.fortHP = Math.max(0, state.pieces.blue.fortHP - dmg);
      log(`Zone orange : forteresse bleue -${dmg} PV.`);
    } else if(redCount >= 2 && blueCount <= 1){
      const dmg=1;
      state.pieces.blue.fortHP = Math.max(0, state.pieces.blue.fortHP - dmg);
      log(`Zone orange : forteresse bleue -${dmg} PV.`);
    }
    // Ensure board re-renders and check game over
    renderBoard();
    checkGameOver();
  }

  // ===== Click handling =====
  function onCellClick(alg, cellEl){
    // Bloquer tout clic si la partie est terminÃ©e
    if(state.gameOver) return;
    // Si un bloc est en cours de placement
    if(state.inProgress && state.inProgress.mode==='BLOCK'){
      // vÃ©rifier si la case cliquÃ©e est une candidate valable
      if(cellEl.classList.contains('target-ok')){
        commitBlockInProgress(alg);
      }
      return;
    }
    // Si un dÃ©placement est en cours
    if(state.inProgress && state.inProgress.mode==='MOVE'){
      const info=state.inProgress; const unit=findUnit(info.color, info.unitId);
      if(!unit || !unit.cell) return;
      // Si clic sur une case qui n'est pas une destination valide
      if(!cellEl.classList.contains('move-ok')){
        // Si aucun pas effectuÃ©, annuler le dÃ©placement
        if(info.remaining === info.initial){ cancelMoveCard(); }
        return;
      }
      const from=unit.cell; unit.cell=alg;
      // update selection cell for highlight
      if(state.selected && state.selected.color===info.color && state.selected.id===unit.id){ state.selected.cell=alg; }
      revealTileIfAny(alg, info.color);
      info.remaining--;
      log(`DÃ©placement carte: ${from} â†’ ${alg} (reste ${info.remaining}).`);
      if(info.remaining<=0){ commitMoveInProgress(); }
      renderBoard(); return;
    }
    // else selection
    const occ=getPieceAt(alg);
    if(occ && occ.color===state.active){ state.selected={color:occ.color,id:occ.unit.id, cell:occ.unit.cell}; applyHighlights(); return; }
    // free move
    if(state.selected && state.freeMoveRemaining>0){ const unit=findUnit(state.selected.color, state.selected.id);
      if(unit && canStep(unit.cell, alg)){
        unit.cell=alg; state.selected.cell=alg; state.freeMoveRemaining--;
        revealTileIfAny(alg,state.active);
        log(`Pas gratuit: ${unit.id} â†’ ${alg}.`);
        renderBoard(); return;
      }
    }
  }

  // ===== End turn =====
  function endTurn(){
    // If we are in the actions phase, switch to preparation: allow discarding up to 2 cards
    if(state.phase === 'actions'){
      state.phase = 'prÃ©paration';
      state.discardLeft = 2;
      // When entering preparation we reset selection and any in-progress actions
      state.inProgress = null;
      state.selected = null;
      state.freeMoveRemaining = 0;
      // Update UI: change button label via renderTop, and show discard buttons via renderHands
      renderTop(); renderBoard(); renderHands();
      log('Phase de prÃ©paration : vous pouvez dÃ©fausser jusqu\'Ã  2 cartes.');
      return;
    }
    // Otherwise we are in prÃ©paration: finalize the turn
    // Apply zone orange damage for both players (dominant side damages the other)
    applyZoneDamage();
    // draw cards for the current player (me)
    if(state.flags.drawTo4){ drawTo(me,4); state.flags.drawTo4=false; } else { drawTo(me,5); }
    // Reset per-turn state
    state.played = 0;
    state.flags = {};
    state.freeMoveRemaining = 1;
    state.inProgress = null;
    state.selected = null;
    state.discardLeft = 0;
    // Advance to next active player, handling first turn mode
    if(state.firstTurnMode){
      if(state.active === state.firstOrder){
        state.immunity.p1 = false;
        state.active = (state.firstOrder === 'blue' ? 'red' : 'blue');
      } else {
        state.immunity.p2 = false;
        state.firstTurnMode = false;
        state.turn = 1;
        state.active = state.firstOrder;
      }
    } else {
      state.active = (state.active === 'blue' ? 'red' : 'blue');
      state.turn++;
    }
    state.phase = 'actions';
    renderTop(); renderBoard(); renderHands();
  }

  // ===== Fin de partie =====
  function checkGameOver(){
    if(state.pieces.blue.fortHP<=0 || state.pieces.red.fortHP<=0){
      const winner = state.pieces.blue.fortHP<=0 ? 'rouge' : 'bleu';
      gameOver(winner);
    }
  }
  function gameOver(winner){
    if(state.gameOver) return;
    state.gameOver = true;
    log('Partie terminÃ©e ! Le joueur '+winner+' a gagnÃ©.');
    // DÃ©sactiver toutes les actions
    document.querySelectorAll('.playbtn').forEach(btn=> btn.disabled=true);
    document.getElementById('btnEndTurn').disabled = true;
    document.getElementById('btnPlaceTiles').disabled = true;
    // Optionnel : offrir de rÃ©initialiser
  }

  // ===== UI top =====
  function renderTop(){
    $('#turnLabel').textContent=state.turn;
    $('#activePlayer').textContent=(state.active==='blue'?'ðŸ”µ Bleu':'ðŸ”´ Rouge');
    $('#phase').textContent=state.phase;
    $('#blueHP').textContent=state.pieces.blue.fortHP;
    $('#redHP').textContent=state.pieces.red.fortHP;
    $('#im1').textContent=state.immunity.p1?'âœ”':'â€”';
    $('#im2').textContent=state.immunity.p2?'âœ”':'â€”';
    $('#blocksActive').textContent=state.blocks.size;
    updateTilesUI();

    // Mettre Ã  jour l'affichage du nombre de cartes jouÃ©es
    const limit = 3 + (state.flags.extraCard ? 1 : 0);
    const played = state.played;
    const cardsEl = document.getElementById('cardsPlayed');
    if(cardsEl) cardsEl.textContent = `${played}/${limit}`;

    // Changer l'Ã©tiquette du bouton de fin de tour en fonction de la phase
    const endBtn = document.getElementById('btnEndTurn');
    if(endBtn){
      if(state.phase === 'actions') endBtn.textContent = 'Fin de tour'; else if(state.phase === 'prÃ©paration') endBtn.textContent = 'Terminer prÃ©paration';
      // DÃ©sactiver le bouton si la partie est finie
      endBtn.disabled = !!state.gameOver;
    }
  }

  // ===== Buttons =====
  $('#btnReset').addEventListener('click', initGame);
  $('#btnPlaceTiles').addEventListener('click', place47);
  $('#btnEndTurn').addEventListener('click', endTurn);
  $('#btnStart').addEventListener('click', ()=>{
    const rB=((Math.random()*6)|0)+1, rR=((Math.random()*6)|0)+1;
    const first = (rB===rR) ? (Math.random()<.5?'blue':'red') : (rB>rR?'blue':'red');
    state.firstOrder=first; state.active=first;
    state.phase='actions'; state.freeMoveRemaining=1;
    log(`Jet ðŸ”µ=${rB}, ðŸ”´=${rR}. ${first==='blue'?'Bleu':'Rouge'} commence. ImmunitÃ© pour l'adversaire.`);
    renderTop(); renderHands();
  });

  // ===== Init =====
  initGame();
  </script>
</body>
</html>